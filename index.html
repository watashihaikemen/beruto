<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>戦神のベルト管理ツール (改善版)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectとの間に少し余白 */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* 合計点数を非表示に */
    .button-group { text-align: center; margin-top: 20px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    /* スコアを元の通り非表示に設定 */
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .saved-belt-delete { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }

    /* ▼▼▼ 修正されたスタイル ▼▼▼ */
    /* カテゴリー別の背景色 */
    .saved-belt-item.category-front   { background-color: #ffebee; } /* 前衛職用: 薄い赤 */
    .saved-belt-item.category-mid     { background-color: #ede7f6; } /* 中衛職用: 薄い紫 */
    .saved-belt-item.category-back    { background-color: #e8eaf6; } /* 後衛職用: 薄い紺 */
    .saved-belt-item.category-pending { background-color: #fff3e0; } /* 保留中: 薄い橙 */
    .saved-belt-item.category-storage { background-color: #f5f5f5; } /* 収納: 薄い灰色 */
    .saved-belt-item.category-general { /* 汎用: 虹色グラデーション */
        background-image: linear-gradient(100deg, #ffebee, #fff3e0, #fffde7, #e8f5e9, #e3f2fd, #ede7f6);
    }

    /* hover時の背景色を少し濃くする */
    .saved-belt-item.category-front:hover   { background-color: #ffcdd2; }
    .saved-belt-item.category-mid:hover     { background-color: #d1c4e9; }
    .saved-belt-item.category-back:hover    { background-color: #c5cae9; }
    .saved-belt-item.category-pending:hover { background-color: #ffe0b2; }
    .saved-belt-item.category-storage:hover { background-color: #eeeeee; }
    .saved-belt-item.category-general:hover {
        background-image: linear-gradient(100deg, #ffcdd2, #ffe0b2, #fff9c4, #c8e6c9, #bbdefb, #d1c4e9);
    }
    /* ▲▲▲ 修正されたスタイル ▲▲▲ */
  </style>
</head>
<body>
  <h1>戦神のベルト管理ツール</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">合計点数: 0.0</div>

  <div class="button-group">
    <button id="saveButton">現在のベルトを保存</button>
  </div>

  <div id="savedBeltsSection">
    <h2>保存されたベルト<span id="savedBeltsCount"></span></h2>

    <div id="filterButtonGroup" class="action-button-group">
      <button data-filter="all">すべて表示</button>
      <button data-filter="general">汎用ベルト</button>
      <button data-filter="front">前衛職用ベルト</button>
      <button data-filter="mid">中衛職用ベルト</button>
      <button data-filter="back">後衛職用ベルト</button>
      <button data-filter="pending">保留中のベルト</button>
      <button data-filter="storage">取り敢えず収納</button>
    </div>

    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">神ベルト順</button>
      <button id="sortTrash">ゴミベルト順</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <script>
    const DATA_VERSION = '1.1';
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';

    function createAllEffectsData() {
        const effectsData = {
            "効果なし": -30, "こうげき力+15": 15, "こうげき力+20": 21.8, "こうげき力+25": 22,
            "こうげき魔力と回復魔力+30": 14.9, "こうげき魔力と回復魔力+40": 21.7, "こうげき魔力と回復魔力+50": 21.9,
            "会心率と呪文暴走率+1.0%": 14.8, "会心率と呪文暴走率+1.5%": 21.7, "会心率と呪文暴走率+2.0%": 21.8,
            "盾装備で開戦時○○系": 0.05
        };
        const weaponEffects = { "片手剣": 18, "両手剣": 17.9, "短剣": 17.8, "スティック": 17.7, "両手杖": 17.6, "ヤリ": 17.5, "オノ": 17.4, "棍": 17.3, "ツメ": 17.2, "ムチ": 17.1, "扇": 17.0, "ハンマー": 16.9, "ブーメラン": 16.8, "弓": 16.7, "鎌": 16.6 };
        const monsterTypes = { "ドラゴン系": 16.5, "虫系": 16.4, "獣系": 16.3, "ゾンビ系": 16.2, "植物系": 16.1, "怪人系": 16.0, "悪魔系": 15.9, "エレ系": 15.8, "鳥系": 15.7, "物質系": 15.6, "スライム系": 15.5, "マシン系": 15.4, "水系": 15.3 };
        const newEffects = { "取り敢えず収納 (カテゴリー用)": 500, "汎用ベルト (カテゴリー用)": 10000, "保留中のベルト (カテゴリー用)": 2000, "前衛職用ベルト (カテゴリー用)": 8000, "中衛職用ベルト (カテゴリー用)": 6000, "後衛職用ベルト (カテゴリー用)": 4000 };
        const elements = ["炎", "氷", "風", "雷", "土", "闇", "光"];
        const percentages = [12, 13, 14, 15];

        for (const weapon in weaponEffects) {
            const baseScore = weaponEffects[weapon];
            for (const element of elements) {
                for (const percentage of percentages) {
                    effectsData[`${weapon}装備時 ${element}の攻撃ダメージ+${percentage}%`] = baseScore + (percentage - 12);
                }
            }
        }
        
        for (const type in monsterTypes) {
            const baseScore = monsterTypes[type];
            for (let i = 0; i < 4; i++) {
                const percentage = 9 + i;
                effectsData[`${type}にダメージ+${percentage}%`] = baseScore + i;
            }
        }

        return { ...newEffects, ...effectsData };
    }

    const ALL_EFFECTS_DATA = createAllEffectsData();
    const FILTERS = {
        'all':       { min: -Infinity, max: Infinity },
        'general':   { min: 10000,     max: 10499 },
        'front':     { min: 8000,      max: 9999 },
        'mid':       { min: 6000,      max: 7999 },
        'back':      { min: 4000,      max: 5999 },
        'pending':   { min: 2000,      max: 3999 },
        'storage':   { min: 500,       max: 1999 }
    };
    let currentFilter = 'all';
    let currentSortDirection = 'divine';

    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    
    const fullOptionsFragment = document.createDocumentFragment();
    const categoryOptionsFragment = document.createDocumentFragment();
    const effectOptionsFragment = document.createDocumentFragment();

    for (let effect in ALL_EFFECTS_DATA) {
        const option = document.createElement('option');
        option.value = effect;
        option.textContent = effect;
        fullOptionsFragment.appendChild(option.cloneNode(true));

        if (effect.includes('(カテゴリー用)') || effect === '効果なし') {
            categoryOptionsFragment.appendChild(option.cloneNode(true));
        }
        if (!effect.includes('(カテゴリー用)') || effect === '効果なし') {
            effectOptionsFragment.appendChild(option.cloneNode(true));
        }
    }

    function migrateSavedBelts() {
        console.log("Checking for data migration...");
        const savedBelts = getSavedBelts();
        if (savedBelts.length === 0) {
            localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
            console.log("No belts to migrate. Set current data version.");
            return;
        }

        const optimizedBelts = savedBelts.map(beltEffects => {
            const category = beltEffects[0] || "効果なし";
            const effects = beltEffects.slice(1);
            effects.sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));
            return [category, ...effects];
        });

        localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(optimizedBelts));
        localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
        console.log(`Data migration complete. ${optimizedBelts.length} belts have been optimized to version ${DATA_VERSION}.`);
    }

    function filterOptions(searchInput, selectElement) {
        const searchTerm = searchInput.value.toLowerCase();
        const currentValue = selectElement.value;

        if (searchTerm === '') {
            selectElement.innerHTML = '';
            if (selectElement.dataset.type === 'category') {
                selectElement.appendChild(categoryOptionsFragment.cloneNode(true));
            } else {
                selectElement.appendChild(effectOptionsFragment.cloneNode(true));
            }
        } else {
            const filteredOptions = Array.from(fullOptionsFragment.children)
                .filter(option => option.textContent.toLowerCase().includes(searchTerm));
            
            selectElement.innerHTML = '';
            filteredOptions.forEach(option => selectElement.appendChild(option.cloneNode(true)));
        }
        
        if (Array.from(selectElement.options).every(opt => opt.value !== currentValue)) {
            const currentOption = document.createElement('option');
            currentOption.value = currentValue;
            currentOption.textContent = currentValue;
            selectElement.insertBefore(currentOption, selectElement.firstChild);
        }
        selectElement.value = currentValue;
    }

    function createEffectSelects() {
        const labels = ["カテゴリー", "効果 1", "効果 2", "効果 3", "効果 4", "効果 5"];
        for (let i = 0; i < 6; i++) {
            const div = document.createElement('div');
            div.className = 'effect-block';
            const label = document.createElement('label');
            label.textContent = labels[i];
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.className = 'effect-search';
            searchInput.placeholder = '効果を検索して絞り込み...';
            const select = document.createElement('select');
            
            if (i === 0) {
                select.dataset.type = 'category';
                select.appendChild(categoryOptionsFragment.cloneNode(true));
            } else {
                select.dataset.type = 'effect';
                select.appendChild(effectOptionsFragment.cloneNode(true));
            }
            select.value = "効果なし";
            
            select.addEventListener('change', () => {
                if (searchInput.value !== '') {
                    searchInput.value = '';
                    filterOptions(searchInput, select);
                }
                updateAndSort();
            });
            searchInput.addEventListener('input', () => filterOptions(searchInput, select));
            div.appendChild(label);
            div.appendChild(searchInput);
            div.appendChild(select);
            container.appendChild(div);
        }
    }

    function updateAndSort() {
        const effectSelects = Array.from(container.querySelectorAll('select[data-type="effect"]'));
        const currentEffectValues = effectSelects.map(select => select.value);
        currentEffectValues.sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));
        effectSelects.forEach((select, index) => {
            const newValue = currentEffectValues[index];
            if (select.value !== newValue) {
                 select.value = newValue;
            }
        });
        
        let total = 0;
        const allSelects = container.querySelectorAll('select');
        allSelects.forEach(select => {
            total += ALL_EFFECTS_DATA[select.value] || 0;
        });
        document.getElementById('totalScore').textContent = `合計点数: ${total.toFixed(1)}`;
    }

    function saveCurrentBelt() {
        const selects = container.querySelectorAll('select');
        const effects = Array.from(selects).map(select => select.value);
        
        if (effects.every(v => v === "効果なし")) return;

        const savedBelts = getSavedBelts();
        
        savedBelts.push(effects);
        localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
        localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
        updateDisplay();
    }

    function getSavedBelts() {
        const savedBelts = localStorage.getItem(SAVED_BELTS_KEY);
        return savedBelts ? JSON.parse(savedBelts) : [];
    }
    
    function calculateTotalScore(effects) {
        return effects.reduce((sum, effect) => sum + (ALL_EFFECTS_DATA[effect] || 0), 0);
    }
    
    function updateDisplay() {
        let savedBelts = getSavedBelts();
        let beltsWithScores = savedBelts.map(effects => ({
            effects: effects,
            score: calculateTotalScore(effects)
        }));

        const filterCriteria = FILTERS[currentFilter];
        const filteredBelts = beltsWithScores.filter(belt => {
            return belt.score >= filterCriteria.min && belt.score <= filterCriteria.max;
        });

        filteredBelts.sort((a, b) => {
            return currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score;
        });

        renderSavedBelts(filteredBelts);
        updateActiveButtons();
    }

    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        
        savedBeltsCountElement.textContent = `(表示: ${beltsToRender.length}個 / 合計: ${totalSavedCount}個)`;

        beltsToRender.forEach((beltData) => {
            const { effects, score } = beltData;
            
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';

            // スコアに基づいてカテゴリークラスを追加
            if (score >= FILTERS.general.min && score <= FILTERS.general.max) {
                beltItem.classList.add('category-general');
            } else if (score >= FILTERS.front.min && score <= FILTERS.front.max) {
                beltItem.classList.add('category-front');
            } else if (score >= FILTERS.mid.min && score <= FILTERS.mid.max) {
                beltItem.classList.add('category-mid');
            } else if (score >= FILTERS.back.min && score <= FILTERS.back.max) {
                beltItem.classList.add('category-back');
            } else if (score >= FILTERS.pending.min && score <= FILTERS.pending.max) {
                beltItem.classList.add('category-pending');
            } else if (score >= FILTERS.storage.min && score <= FILTERS.storage.max) {
                beltItem.classList.add('category-storage');
            }

            const beltInfo = document.createElement('div');
            beltInfo.className = 'saved-belt-info';
            const validEffects = effects.filter(e => e !== '効果なし');
            beltInfo.addEventListener('click', () => loadBelt(effects));
            const scoreDisplay = document.createElement('strong');
            scoreDisplay.textContent = `合計点数: ${score.toFixed(1)}`;
            beltInfo.appendChild(scoreDisplay);

            validEffects.forEach(effect => {
                const effectSpan = document.createElement('span');
                effectSpan.textContent = effect;
                beltInfo.appendChild(effectSpan);
            });

            const deleteButton = document.createElement('button');
            deleteButton.className = 'saved-belt-delete';
            deleteButton.textContent = '削除';
            deleteButton.addEventListener('click', (e) => {
              e.stopPropagation();
              deleteBelt(effects);
            });

            beltItem.appendChild(beltInfo);
            beltItem.appendChild(deleteButton);
            savedBeltsList.appendChild(beltItem);
        });
    }

    function updateActiveButtons() {
        filterButtonGroup.querySelectorAll('button').forEach(button => {
            button.classList.toggle('active', button.dataset.filter === currentFilter);
        });
        sortButtonGroup.querySelectorAll('button').forEach(button => {
            const sortId = button.id;
            const isActive = (sortId === 'sortDivine' && currentSortDirection === 'divine') || 
                             (sortId === 'sortTrash' && currentSortDirection === 'trash');
            button.classList.toggle('active', isActive);
        });
    }

    function loadBelt(effects) {
        const selects = container.querySelectorAll('select');
        const searchInputs = container.querySelectorAll('.effect-search');

        searchInputs.forEach((input, index) => {
            if (input.value !== '') {
                input.value = '';
                filterOptions(input, selects[index]);
            }
        });
        
        selects.forEach((select, index) => {
            select.value = effects[index] || "効果なし";
        });
        
        updateAndSort();
        window.scrollTo(0, 0);
    }

    function deleteBelt(effectsToDelete) {
        let savedBelts = getSavedBelts();
        const effectsToDeleteStr = JSON.stringify(effectsToDelete);
        const indexToDelete = savedBelts.findIndex(belt => JSON.stringify(belt) === effectsToDeleteStr);

        if (indexToDelete > -1) {
            savedBelts.splice(indexToDelete, 1);
            localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
            updateDisplay();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion !== DATA_VERSION) {
            migrateSavedBelts();
        }

        createEffectSelects();
        updateAndSort();
        
        saveButton.addEventListener('click', saveCurrentBelt);

        filterButtonGroup.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                currentFilter = button.dataset.filter;
                updateDisplay();
            });
        });

        sortDivineButton.addEventListener('click', () => {
            currentSortDirection = 'divine';
            updateDisplay();
        });
        sortTrashButton.addEventListener('click', () => {
            currentSortDirection = 'trash';
            updateDisplay();
        });

        updateDisplay();
    });
  </script>
</body>
</html>
