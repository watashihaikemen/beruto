<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>戦神のベルト管理ツール (ver1.6)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectとの間に少し余白 */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* 合計点数を非表示に */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }

    /* カテゴリーごとの色を定義 */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } /* 片手剣 */
    .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } /* 両手剣 */
    .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } /* 短剣 */
    .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } /* スティック */
    .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } /* 両手杖 */
    .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } /* ヤリ */
    .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } /* オノ */
    .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } /* 棍 */
    .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } /* ツメ */
    .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } /* ムチ */
    .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } /* 扇 */
    .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } /* ハンマー */
    .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } /* ブーメラン */
    .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } /* 弓 */
    .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; } /* 鎌 */
    
    /* 封印設定モーダル用のスタイル */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* トースト通知用のスタイル */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>戦神のベルト管理ツール</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">合計点数: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">封印効果の管理</button>
    <button id="saveButton">現在のベルトを保存</button>
  </div>

  <div id="savedBeltsSection">
    <h2>保存されたベルト<span id="savedBeltsCount"></span></h2>
    <div id="filterButtonGroup" class="action-button-group"></div>
    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">神ベルト順</button>
      <button id="sortTrash">ゴミベルト順</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>封印効果の管理</span><span id="sealedCount"></span></h2>
        <p>封印したい効果にチェックを入れてください。チェックした効果は、効果選択のプルダウンに表示されなくなります。選択後、保存するボタンを押してください。</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">キャンセル</button>
            <button id="saveSealSettingsButton">保存する</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    const DATA_VERSION = '1.6'; // 自動ソート機能の不具合を修正
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';

    // 定数やDOM要素取得などの定義 (変更なしのため一部省略)
    const WEAPON_EFFECTS = { "片手剣": 18, "両手剣": 17.9, "短剣": 17.8, "スティック": 17.7, "両手杖": 17.6, "ヤリ": 17.5, "オノ": 17.4, "棍": 17.3, "ツメ": 17.2, "ムチ": 17.1, "扇": 17.0, "ハンマー": 16.9, "ブーメラン": 16.8, "弓": 16.7, "鎌": 16.6 };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const ELEMENTS = ["炎", "氷", "風", "雷", "土", "闇", "光"];
    const MONSTER_TYPES = { "ドラゴン系": 16.5, "虫系": 16.4, "獣系": 16.3, "ゾンビ系": 16.2, "植物系": 16.1, "怪人系": 16.0, "悪魔系": 15.9, "エレ系": 15.8, "鳥系": 15.7, "物質系": 15.6, "スライム系": 15.5, "マシン系": 15.4, "水系": 15.3 };
    function createAllEffectsData(){const e={"効果なし":-30,"こうげき力+15":15,"こうげき力+20":21.8,"こうげき力+25":22,"こうげき魔力と回復魔力+30":14.9,"こうげき魔力と回復魔力+40":21.7,"こうげき魔力と回復魔力+50":21.9,"会心率と呪文暴走率+1.0%":14.8,"会心率と呪文暴走率+1.5%":21.7,"会心率と呪文暴走率+2.0%":21.8,"盾装備で開戦時○○系":.05},t={"汎用ベルト (カテゴリー用)":4e4,"保留中のベルト (カテゴリー用)":6e3,"取り敢えず収納 (カテゴリー用)":4e3};let a=38e3;return WEAPON_NAMES.forEach(n=>{t[`${n}用ベルト (カテゴリー用)`]=a,a-=2e3}),Object.keys(WEAPON_EFFECTS).forEach(t=>{const a=WEAPON_EFFECTS[t];ELEMENTS.forEach(n=>{[12,13,14,15].forEach(o=>{e[`${t}装備時 ${n}の攻撃ダメージ+${o}%`]=a+o-12})})}),Object.keys(MONSTER_TYPES).forEach(t=>{const a=MONSTER_TYPES[t];for(let n=0;n<4;n++)e[`${t}にダメージ+${9+n}%`]=a+n}),{...t,...e}}
    const ALL_EFFECTS_DATA = createAllEffectsData();
    let sealableGroups = [];
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    function createFilters(){const e={all:{min:-1/0,max:1/0},general:{min:39849,max:40499},pending:{min:5849,max:7848},storage:{min:3849,max:5848}};let t=38e3;return WEAPON_NAMES.forEach(a=>{const n=t-2e3;e[a]={min:n+1849,max:t+1848},t-=2e3}),e}
    const FILTERS = createFilters();
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    const sealSettingsButton = document.getElementById('sealSettingsButton');
    const sealModal = document.getElementById('sealModal');
    const sealActionButtonsContainer = document.getElementById('sealActionButtons');
    const sealGroupsContainer = document.getElementById('sealGroupsContainer');
    const saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
    const cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
    const sealedCountElement = document.getElementById('sealedCount');
    const toastContainer = document.getElementById('toast-container');
    
    function showToast(message) { /* 省略 (変更なし) */ }
    function populateSealModal() { /* 省略 (変更なし) */ }
    function saveSealSettings() { /* 省略 (変更なし) */ }
    function updateAllSelectOptions() { /* 省略 (変更なし) */ }
    function migrateSavedBelts() { /* 省略 (変更なし) */ }
    function saveCurrentBelt() { /* 省略 (変更なし) */ }
    function deleteBelt(effectsToDelete) { /* 省略 (変更なし) */ }
    function editMemo(effectsToEdit) { /* 省略 (変更なし) */ }
    function renderSavedBelts(beltsToRender) { /* 省略 (変更なし) */ }
    function getSealedGroups(){const e=localStorage.getItem(SEALED_EFFECTS_KEY);return e?JSON.parse(e):[]}
    function isEffectSealed(e,t){return!(!t||0===t.length)&&t.some(t=>e.startsWith(t.replace(/\+\?%?/,"").replace("○○系","")))}
    function updateSealedCount(){if(sealableGroups&&0!==sealableGroups.length){const e=sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length,t=sealableGroups.length;sealedCountElement.textContent=`(${e} / ${t} 件 封印中)`}}
    function rebuildOptionFragments(){fullOptionsFragment=document.createDocumentFragment(),categoryOptionsFragment=document.createDocumentFragment(),effectOptionsFragment=document.createDocumentFragment();const e=getSealedGroups();for(let t in ALL_EFFECTS_DATA){if(isEffectSealed(t,e))continue;const a=document.createElement("option");a.value=t,a.textContent=t,fullOptionsFragment.appendChild(a.cloneNode(!0)),(t.includes("(カテゴリー用)")||"効果なし"===t)&&categoryOptionsFragment.appendChild(a.cloneNode(!0)),t.includes("(カテゴリー用)")&&"効果なし"!==t||effectOptionsFragment.appendChild(a.cloneNode(!0))}}
    function createEffectSelects(){const e=["カテゴリー","効果 1","効果 2","効果 3","効果 4","効果 5"];for(let t=0;t<6;t++){const a=document.createElement("div");a.className="effect-block";const n=document.createElement("label");n.textContent=e[t];const o=document.createElement("input");o.type="text",o.className="effect-search",o.placeholder="効果を検索して絞り込み...";const l=document.createElement("select");l.dataset.type=0===t?"category":"effect",l.addEventListener("change",updateAndSort),o.addEventListener("input",updateAndSort),a.appendChild(n),a.appendChild(o),a.appendChild(l),container.appendChild(a)}updateAllSelectOptions()}
    function createFilterButtons(){filterButtonGroup.innerHTML="";const e=[{filter:"all",text:"すべて表示"},{filter:"general",text:"汎用ベルト"},...WEAPON_NAMES.map(e=>({filter:e,text:`${e}用`})),{filter:"pending",text:"保留中のベルト"},{filter:"storage",text:"取り敢えず収納"}];e.forEach(({filter:e,text:t})=>{const a=document.createElement("button");a.dataset.filter=e,a.textContent=t,a.addEventListener("click",()=>{currentFilter=a.dataset.filter,updateDisplay()}),filterButtonGroup.appendChild(a)})}
    function getSavedBelts(e=!1){const t=localStorage.getItem(SAVED_BELTS_KEY);return e?t?JSON.parse(t):[]:t?JSON.parse(t):[]}
    function calculateTotalScore(e){return e.reduce((e,t)=>e+(ALL_EFFECTS_DATA[t]||0),0)}
    function updateDisplay(){let e=getSavedBelts();let t=e.map(e=>({...e,score:calculateTotalScore(e.effects)}));const a=FILTERS[currentFilter],n=t.filter(e=>a&&e.score>=a.min&&e.score<=a.max);n.sort((e,t)=>"divine"===currentSortDirection?t.score-e.score:e.score-t.score),renderSavedBelts(n),updateActiveButtons()}
    function toggleLockState(e){let t=getSavedBelts();const a=JSON.stringify(e),n=t.find(e=>JSON.stringify(e.effects)===a);n&&(n.locked=!n.locked,localStorage.setItem(SAVED_BELTS_KEY,JSON.stringify(t)),updateDisplay(),showToast(n.locked?"ベルトをロックしました。":"ベルトのロックを解除しました。"))}
    function updateActiveButtons(){filterButtonGroup.querySelectorAll("button").forEach(e=>{e.classList.toggle("active",e.dataset.filter===currentFilter)}),sortButtonGroup.querySelectorAll("button").forEach(e=>{const t=e.id;e.classList.toggle("active","sortDivine"===t&&"divine"===currentSortDirection||"sortTrash"===t&&"trash"===currentSortDirection)})}
    function loadBelt(e){const t=container.querySelectorAll("select"),a=container.querySelectorAll(".effect-search");a.forEach((e)=>{e.value=""}),t.forEach((t,a)=>{t.value=e[a]||"効果なし"}),updateAndSort(),window.scrollTo(0,0)}
    function generateSealableGroups(){const e=[];e.push({group:"こうげき力+?",score:ALL_EFFECTS_DATA["こうげき力+25"]}),e.push({group:"こうげき魔力と回復魔力+?",score:ALL_EFFECTS_DATA["こうげき魔力と回復魔力+50"]}),e.push({group:"会心率と呪文暴走率+?%",score:ALL_EFFECTS_DATA["会心率と呪文暴走率+2.0%"]}),WEAPON_NAMES.forEach(t=>{const a=WEAPON_EFFECTS[t];ELEMENTS.forEach(n=>{e.push({group:`${t}装備時 ${n}の攻撃ダメージ+?%`,score:a+3})})}),Object.keys(MONSTER_TYPES).forEach(t=>{const a=MONSTER_TYPES[t];e.push({group:`${t}にダメージ+?%`,score:a+3})}),e.push({group:"盾装備で開戦時○○系",score:ALL_EFFECTS_DATA["盾装備で開戦時○○系"]}),e.sort((e,t)=>{if(t.score!==e.score)return t.score-e.score;e.group.localeCompare(t.group,"ja")}),sealableGroups=e.map(e=>e.group)}
    
    function getGroupKeyForEffect(effect) {
        if (!effect || effect === '効果なし' || effect.includes('(カテゴリー用)')) { return null; }
        const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim();
        if (key && key !== effect) { return key; }
        return effect;
    }

    // ★★★ 変更点：自動ソート処理の不具合を修正 ★★★
    let isSorting = false;
    function updateAndSort() {
        if (isSorting) return;
        isSorting = true;

        // --- 1. 自動ソート処理 ---
        const effectSelects = Array.from(container.querySelectorAll('select[data-type="effect"]'));
        const effectValues = effectSelects.map(s => s.value);
        const sortedValues = [...effectValues].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));

        // --- 2. ソート後の値を設定する準備 ---
        // 各プルダウンに、これから設定される可能性のある値を一時的にoptionとして追加する
        // これにより、次のステップで .value に値を設定する際に確実に成功する
        effectSelects.forEach(select => {
            sortedValues.forEach(value => {
                if (value !== '効果なし') {
                    // 既にそのoptionが存在しない場合のみ追加
                    // CSS.escapeは、optionのvalueに特殊文字が含まれてもセレクタが正しく動作するようにするため
                    if (!select.querySelector(`option[value="${CSS.escape(value)}"]`)) {
                        const tempOption = document.createElement('option');
                        tempOption.value = value;
                        tempOption.textContent = value;
                        select.appendChild(tempOption);
                    }
                }
            });
        });

        // --- 3. ソート後の値を各プルダウンに反映 ---
        effectSelects.forEach((select, index) => {
            select.value = sortedValues[index];
        });

        // --- 4. 選択肢の動的更新 & 再構築 ---
        const allSelects = Array.from(container.querySelectorAll('select'));
        const searchInputs = Array.from(container.querySelectorAll('.effect-search'));
        const currentAllValues = allSelects.map(s => s.value);

        allSelects.forEach((currentSelect, selectIndex) => {
            // このプルダウン「以外」で使われているグループキーのセットを作成
            const otherUsedGroupKeys = new Set();
            currentAllValues.forEach((value, valueIndex) => {
                if (selectIndex !== valueIndex) {
                    const groupKey = getGroupKeyForEffect(value);
                    if (groupKey) {
                        otherUsedGroupKeys.add(groupKey);
                    }
                }
            });

            const currentValue = currentSelect.value;
            const searchTerm = searchInputs[selectIndex] ? searchInputs[selectIndex].value.toLowerCase() : '';
            const sourceFragment = currentSelect.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();

            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const optionText = optionNode.textContent.toLowerCase();

                // 表示条件: グループ化対象外、または、他のプルダウンで使われていないグループ
                const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey);
                const matchesSearch = !searchTerm || optionText.includes(searchTerm);

                if (isSelectableByGroup && matchesSearch) {
                    newOptionsFragment.appendChild(optionNode.cloneNode(true));
                }
            });
            
            // 選択肢をクリアして、新しく生成したもので上書き
            currentSelect.innerHTML = '';
            currentSelect.appendChild(newOptionsFragment);
            
            // 現在選択中の値が、フィルター後の選択肢リストから消えてしまった場合でも、
            // その値を保持するためにoptionを強制的に追加する
            const valueExists = Array.from(currentSelect.options).some(opt => opt.value === currentValue);
            if (!valueExists && currentValue !== '効果なし') {
                const restoredOption = document.createElement('option');
                restoredOption.value = currentValue;
                restoredOption.textContent = currentValue;
                currentSelect.insertBefore(restoredOption, currentSelect.firstChild);
            }
            currentSelect.value = currentValue;
        });

        // --- 5. スコア計算 ---
        let totalScore = 0;
        allSelects.forEach(select => {
            totalScore += ALL_EFFECTS_DATA[select.value] || 0;
        });
        document.getElementById("totalScore").textContent = `合計点数: ${totalScore.toFixed(1)}`;

        isSorting = false;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion !== DATA_VERSION) {
            migrateSavedBelts();
        }
        generateSealableGroups();
        createEffectSelects();
        createFilterButtons();
        updateAndSort();
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', (e) => { if (e.target === sealModal) sealModal.style.display = 'none'; });
        updateDisplay();
    });
  </script>
</body>
</html>
