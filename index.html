<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ« å†ä¿®æ­£(ver1.8.1)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* åˆè¨ˆç‚¹æ•°ã‚’éè¡¨ç¤ºã« */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; align-items: center; gap: 12px; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-item.selected { background-color: #e6f7ff; border-left-color: #007bff; }
    .belt-selector { flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .action-button-group button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.7; }
    #bulkActionsContainer { border-bottom: 1px solid #ddd; padding-bottom: 15px; }
    #deleteAllUnlockedButton { background-color: #c82333; color: white; border-color: #c82333; }
    #deleteAllUnlockedButton:hover { background-color: #a71d2a; }

    /* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã”ã¨ã®è‰²ã‚’å®šç¾© */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; }

    /* å°å°è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ«</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">åˆè¨ˆç‚¹æ•°: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">å°å°åŠ¹æœã®ç®¡ç†</button>
    <button id="saveButton">ç¾åœ¨ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜</button>
  </div>

  <div id="savedBeltsSection">
    <h2>ä¿å­˜ã•ã‚ŒãŸãƒ™ãƒ«ãƒˆ<span id="savedBeltsCount"></span></h2>
    <div id="bulkActionsContainer" class="action-button-group"></div>
    <div id="filterButtonGroup" class="action-button-group"></div>
    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">ç¥ãƒ™ãƒ«ãƒˆé †</button>
      <button id="sortTrash">ã‚´ãƒŸãƒ™ãƒ«ãƒˆé †</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>å°å°åŠ¹æœã®ç®¡ç†</span><span id="sealedCount"></span></h2>
        <p>å°å°ã—ãŸã„åŠ¹æœã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚ãƒã‚§ãƒƒã‚¯ã—ãŸåŠ¹æœã¯ã€åŠ¹æœé¸æŠã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¡¨ç¤ºã•ã‚Œãªããªã‚Šã¾ã™ã€‚é¸æŠå¾Œã€ä¿å­˜ã™ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="saveSealSettingsButton">ä¿å­˜ã™ã‚‹</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’1.8.1ã«æ›´æ–°ï¼ˆãƒ­ãƒƒã‚¯è§£é™¤æ©Ÿèƒ½è¿½åŠ ï¼‰â˜…â˜…â˜…
    const DATA_VERSION = '1.8.1'; 
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';

    const WEAPON_EFFECTS = { "ç‰‡æ‰‹å‰£": 18, "ä¸¡æ‰‹å‰£": 17.9, "çŸ­å‰£": 17.8, "ã‚¹ãƒ†ã‚£ãƒƒã‚¯": 17.7, "ä¸¡æ‰‹æ–": 17.6, "ãƒ¤ãƒª": 17.5, "ã‚ªãƒ": 17.4, "æ£": 17.3, "ãƒ„ãƒ¡": 17.2, "ãƒ ãƒ": 17.1, "æ‰‡": 17.0, "ãƒãƒ³ãƒãƒ¼": 16.9, "ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³": 16.8, "å¼“": 16.7, "éŒ": 16.6 };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const ELEMENTS = ["ç‚", "æ°·", "é¢¨", "é›·", "åœŸ", "é—‡", "å…‰"];
    const MONSTER_TYPES = { "ãƒ‰ãƒ©ã‚´ãƒ³ç³»": 16.5, "è™«ç³»": 16.4, "ç£ç³»": 16.3, "ã‚¾ãƒ³ãƒ“ç³»": 16.2, "æ¤ç‰©ç³»": 16.1, "æ€ªäººç³»": 16.0, "æ‚ªé­”ç³»": 15.9, "ã‚¨ãƒ¬ç³»": 15.8, "é³¥ç³»": 15.7, "ç‰©è³ªç³»": 15.6, "ã‚¹ãƒ©ã‚¤ãƒ ç³»": 15.5, "ãƒã‚·ãƒ³ç³»": 15.4, "æ°´ç³»": 15.3 };
    
    function createAllEffectsData() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const categoryScores = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 40000, "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 6000, "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 4000 }; let weaponScore = 38000; WEAPON_NAMES.forEach(name => { categoryScores[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = weaponScore; weaponScore -= 2000; }); const effectScores = { "åŠ¹æœãªã—": -30, "ã“ã†ã’ãåŠ›+15": 15, "ã“ã†ã’ãåŠ›+20": 21.8, "ã“ã†ã’ãåŠ›+25": 22, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+30": 14.9, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+40": 21.7, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50": 21.9, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.0%": 14.8, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.5%": 21.7, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%": 21.8, "ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»": 0.05 }; Object.keys(WEAPON_EFFECTS).forEach(weapon => { const baseScore = WEAPON_EFFECTS[weapon]; ELEMENTS.forEach(element => { [12, 13, 14, 15].forEach(val => { effectScores[`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+${val}%`] = baseScore + (val - 12); }); }); }); Object.keys(MONSTER_TYPES).forEach(type => { const baseScore = MONSTER_TYPES[type]; for(let i = 0; i < 4; i++) { effectScores[`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+${9+i}%`] = baseScore + i; } }); return { ...categoryScores, ...effectScores }; }
    const ALL_EFFECTS_DATA = createAllEffectsData();
    
    function createFilters() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } }; let weaponScore = 38000; WEAPON_NAMES.forEach(name => { const minScore = weaponScore - 2000; filters[name] = { min: minScore + 1849, max: weaponScore + 1848 }; weaponScore -= 2000; }); return filters; }
    const FILTERS = createFilters();

    // === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ===
    let sealableGroups = [];
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    let isSorting = false;

    // === DOMè¦ç´ ã®å–å¾— ===
    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    const sealSettingsButton = document.getElementById('sealSettingsButton');
    const sealModal = document.getElementById('sealModal');
    const sealActionButtonsContainer = document.getElementById('sealActionButtons');
    const sealGroupsContainer = document.getElementById('sealGroupsContainer');
    const saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
    const cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
    const sealedCountElement = document.getElementById('sealedCount');
    const toastContainer = document.getElementById('toast-container');
    const bulkActionsContainer = document.getElementById('bulkActionsContainer');
    let selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton;

    // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ===
    function showToast(message) { /* çœç•¥ (å¤‰æ›´ãªã—) */ const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = message; toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
    function getSavedBelts() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const beltsJSON = localStorage.getItem(SAVED_BELTS_KEY); return beltsJSON ? JSON.parse(beltsJSON) : []; }
    function calculateTotalScore(effects) { /* çœç•¥ (å¤‰æ›´ãªã—) */ return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0); }
    function getGroupKeyForEffect(effect) { /* çœç•¥ (å¤‰æ›´ãªã—) */ if (!effect || effect === 'åŠ¹æœãªã—' || effect.includes('(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)')) { return null; } const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim(); if (key && key !== effect) { return key; } return effect; }

    // === å°å°æ©Ÿèƒ½é–¢é€£ ===
    function getSealedGroups() { /* çœç•¥ (å¤‰æ›´ãªã—) */ return localStorage.getItem(SEALED_EFFECTS_KEY) ? JSON.parse(localStorage.getItem(SEALED_EFFECTS_KEY)) : []; }
    function isEffectSealed(effect, sealedGroups) { /* çœç•¥ (å¤‰æ›´ãªã—) */ if (!sealedGroups || sealedGroups.length === 0) return false; const groupKey = getGroupKeyForEffect(effect); if (groupKey) { const genericGroupKey = groupKey.replace(/è£…å‚™æ™‚ |ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸/, "è£…å‚™æ™‚ â—‹â—‹ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸").replace(/ã«ãƒ€ãƒ¡ãƒ¼ã‚¸/, "ã«ãƒ€ãƒ¡ãƒ¼ã‚¸") + "+?%"; const simpleKey = groupKey + "+?"; if (sealedGroups.some(g => g.startsWith(groupKey))) return true; } return sealedGroups.some(groupPrefix => effect.startsWith(groupPrefix.replace(/\+\?%?/, '').replace("â—‹â—‹ç³»", ""))); }
    function updateSealedCount() { /* çœç•¥ (å¤‰æ›´ãªã—) */ if (!sealableGroups || sealableGroups.length === 0) return; const checkedCount = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length; const totalCount = sealableGroups.length; sealedCountElement.textContent = `(${checkedCount} / ${totalCount} ä»¶ å°å°ä¸­)`; }
    function populateSealModal() { /* çœç•¥ (å¤‰æ›´ãªã—) */ sealActionButtonsContainer.innerHTML = ''; const selectAllButton = document.createElement('button'); selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ'; selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); }); const deselectAllButton = document.createElement('button'); deselectAllButton.textContent = 'ã™ã¹ã¦è§£é™¤'; deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); }); sealActionButtonsContainer.appendChild(selectAllButton); sealActionButtonsContainer.appendChild(deselectAllButton); sealGroupsContainer.innerHTML = ''; const sealedGroups = getSealedGroups(); sealableGroups.forEach(group => { const div = document.createElement('div'); div.className = 'seal-group'; const label = document.createElement('label'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group); checkbox.addEventListener('change', updateSealedCount); label.appendChild(checkbox); label.appendChild(document.createTextNode(group)); div.appendChild(label); sealGroupsContainer.appendChild(div); }); updateSealedCount(); }
    function saveSealSettings() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked'); const sealedGroups = Array.from(checkboxes).map(cb => cb.value); localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups)); sealModal.style.display = 'none'; updateAllSelectOptions(); showToast("å°å°è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚"); }

    // === ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç† (ä¿å­˜/å‰Šé™¤/æ›´æ–°) ===
    function migrateSavedBelts() { /* çœç•¥ (å¤‰æ›´ãªã—) */ let savedBelts = getSavedBelts(); const storedVersion = localStorage.getItem(DATA_VERSION_KEY); if (storedVersion === DATA_VERSION || savedBelts.length === 0) { localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION); return; } const migratedBelts = savedBelts.map(belt => { if (Array.isArray(belt)) { return { effects: belt, locked: false, memo: '' }; } if (typeof belt !== 'object' || belt === null) return null; if (!Array.isArray(belt.effects)) return null; return { effects: belt.effects, locked: belt.locked === true, memo: belt.memo || '' }; }).filter(Boolean); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(migratedBelts)); localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION); console.log("ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ver " + DATA_VERSION + " ã«æ›´æ–°ã—ã¾ã—ãŸã€‚"); }
    function saveCurrentBelt() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const selects = container.querySelectorAll('select'); const currentEffects = Array.from(selects).map(s => s.value); const validEffectsCount = currentEffects.slice(1).filter(e => e !== 'åŠ¹æœãªã—').length; if (validEffectsCount < 1) { showToast("æœ‰åŠ¹ãªåŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚"); return; } const savedBelts = getSavedBelts(); const newBeltData = { effects: currentEffects, locked: false, memo: '' }; const isDuplicate = savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects)); if (isDuplicate) { showToast("ã“ã®åŠ¹æœã®çµ„ã¿åˆã‚ã›ã¯æ—¢ã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"); return; } savedBelts.push(newBeltData); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast("ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸï¼"); updateDisplay(); }
    function deleteBelt(effectsToDelete) { /* çœç•¥ (å¤‰æ›´ãªã—) */ if (!confirm("ã“ã®ãƒ™ãƒ«ãƒˆã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; let savedBelts = getSavedBelts(); const effectsToDeleteStr = JSON.stringify(effectsToDelete); const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts)); showToast("ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); }
    function editMemo(effectsToEdit) { /* çœç•¥ (å¤‰æ›´ãªã—) */ let savedBelts = getSavedBelts(); const effectsToEditStr = JSON.stringify(effectsToEdit); const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr); if (beltToEdit) { const newMemo = prompt("ãƒ™ãƒ«ãƒˆã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", beltToEdit.memo || ""); if (newMemo !== null) { beltToEdit.memo = newMemo.trim(); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast("ãƒ¡ãƒ¢ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚"); updateDisplay(); } } }
    function toggleLockState(effectsToToggle) { /* çœç•¥ (å¤‰æ›´ãªã—) */ let savedBelts = getSavedBelts(); const effectsToToggleStr = JSON.stringify(effectsToToggle); const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr); if (beltToToggle) { beltToToggle.locked = !beltToToggle.locked; localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast(beltToToggle.locked ? "ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚" : "ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); } }

    // === è¡¨ç¤ºé–¢é€£ ===
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(è¡¨ç¤º: ${beltsToRender.length}å€‹ / åˆè¨ˆ: ${totalSavedCount}å€‹)`;
        const categoryClassMap = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-general", "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-pending", "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-storage" };
        WEAPON_NAMES.forEach((name, index) => { categoryClassMap[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = `category-weapon-${index}`; });
        if (beltsToRender.length === 0) {
            const noBeltMessage = document.createElement('p');
            noBeltMessage.textContent = 'è¡¨ç¤ºå¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
            noBeltMessage.style.textAlign = 'center'; noBeltMessage.style.color = '#888';
            savedBeltsList.appendChild(noBeltMessage);
            updateBulkActionButtonsState(); // â˜…ãƒ™ãƒ«ãƒˆãŒãªã„å ´åˆã‚‚ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ›´æ–°
            return;
        }
        beltsToRender.forEach((beltData) => {
            const { effects, locked, memo } = beltData;
            const categoryEffect = effects[0] || 'åŠ¹æœãªã—';
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            const categoryClassName = categoryClassMap[categoryEffect] || 'category-default';
            beltItem.classList.add(categoryClassName);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'belt-selector';
            checkbox.dataset.effectsJson = JSON.stringify(effects);
            checkbox.addEventListener('change', () => {
                beltItem.classList.toggle('selected', checkbox.checked);
                updateBulkActionButtonsState();
            });
            beltItem.appendChild(checkbox);

            const beltInfo = document.createElement('div');
            beltInfo.className = 'saved-belt-info';
            beltInfo.addEventListener('click', () => loadBelt(effects));
            const validEffects = effects.filter(e => e !== 'åŠ¹æœãªã—');
            validEffects.forEach(effect => { const effectSpan = document.createElement('span'); effectSpan.textContent = effect; beltInfo.appendChild(effectSpan); });
            if (memo) { const memoSpan = document.createElement('span'); memoSpan.className = 'belt-memo'; memoSpan.textContent = `ğŸ“ ${memo}`; beltInfo.appendChild(memoSpan); }
            const actionButtons = document.createElement('div');
            actionButtons.className = 'saved-belt-actions';
            const upperActions = document.createElement('div');
            upperActions.className = 'saved-belt-actions-upper';
            const lockButton = document.createElement('button');
            lockButton.className = 'saved-belt-lock'; lockButton.textContent = locked ? 'è§£é™¤' : 'ãƒ­ãƒƒã‚¯';
            lockButton.addEventListener('click', (e) => { e.stopPropagation(); toggleLockState(effects); });
            const deleteButton = document.createElement('button');
            deleteButton.className = 'saved-belt-delete'; deleteButton.textContent = 'å‰Šé™¤'; deleteButton.disabled = locked;
            deleteButton.addEventListener('click', (e) => { e.stopPropagation(); deleteBelt(effects); });
            upperActions.appendChild(lockButton);
            upperActions.appendChild(deleteButton);
            const memoEditButton = document.createElement('button');
            memoEditButton.className = 'saved-belt-memo-edit'; memoEditButton.textContent = 'ãƒ¡ãƒ¢ç·¨é›†';
            memoEditButton.addEventListener('click', (e) => { e.stopPropagation(); editMemo(effects); });
            actionButtons.appendChild(upperActions);
            actionButtons.appendChild(memoEditButton);
            beltItem.appendChild(beltInfo);
            beltItem.appendChild(actionButtons);
            savedBeltsList.appendChild(beltItem);
        });
        updateBulkActionButtonsState();
    }
    
    // === ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã®ç”Ÿæˆãƒ»æ›´æ–° ===
    function rebuildOptionFragments() { /* çœç•¥ (å¤‰æ›´ãªã—) */ fullOptionsFragment = document.createDocumentFragment(); categoryOptionsFragment = document.createDocumentFragment(); effectOptionsFragment = document.createDocumentFragment(); const sealedGroups = getSealedGroups(); for (const effectName in ALL_EFFECTS_DATA) { if (isEffectSealed(effectName, sealedGroups)) continue; const option = document.createElement("option"); option.value = effectName; option.textContent = effectName; fullOptionsFragment.appendChild(option.cloneNode(true)); if (effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") { categoryOptionsFragment.appendChild(option.cloneNode(true)); } if (!effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") { effectOptionsFragment.appendChild(option.cloneNode(true)); } } }
    function updateAllSelectOptions() { /* çœç•¥ (å¤‰æ›´ãªã—) */ rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const currentValue = select.value; const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.innerHTML = ""; select.appendChild(sourceFragment.cloneNode(true)); if (Array.from(select.options).some(o => o.value === currentValue)) { select.value = currentValue; } else { select.value = "åŠ¹æœãªã—"; } }); updateAndSort(); }
    
    // === ä¸¦ã³æ›¿ãˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®ãƒ¡ã‚¤ãƒ³é–¢æ•° ===
    function updateAndSort() { /* çœç•¥ (å¤‰æ›´ãªã—) */ if (isSorting) return; isSorting = true; const allSelects = Array.from(container.querySelectorAll('select')); const searchInputs = Array.from(container.querySelectorAll('.effect-search')); const originalValues = allSelects.map(s => s.value); const categoryValue = originalValues[0]; const effectsForSorting = originalValues.slice(1); const sortedEffects = [...effectsForSorting].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0)); const finalValues = [categoryValue, ...sortedEffects]; allSelects.forEach((select, currentIndex) => { const finalValueForThisSelect = finalValues[currentIndex]; const searchTerm = searchInputs[currentIndex] ? searchInputs[currentIndex].value.toLowerCase() : ''; const otherUsedGroupKeys = new Set(); finalValues.forEach((value, index) => { if (currentIndex !== index && value !== 'åŠ¹æœãªã—') { const groupKey = getGroupKeyForEffect(value); if (groupKey) { otherUsedGroupKeys.add(groupKey); } } }); const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment; const newOptionsFragment = document.createDocumentFragment(); Array.from(sourceFragment.children).forEach(optionNode => { const optionValue = optionNode.value; const optionGroupKey = getGroupKeyForEffect(optionValue); const optionText = optionNode.textContent.toLowerCase(); const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === finalValueForThisSelect; const matchesSearch = !searchTerm || optionText.includes(searchTerm); if (isSelectableByGroup && matchesSearch) { newOptionsFragment.appendChild(optionNode.cloneNode(true)); } }); select.innerHTML = ''; select.appendChild(newOptionsFragment); const valueExists = Array.from(select.options).some(opt => opt.value === finalValueForThisSelect); if (!valueExists && finalValueForThisSelect !== 'åŠ¹æœãªã—') { const restoredOption = document.createElement('option'); restoredOption.value = finalValueForThisSelect; restoredOption.textContent = finalValueForThisSelect; select.insertBefore(restoredOption, select.firstChild); } select.value = finalValueForThisSelect; }); const totalScore = calculateTotalScore(finalValues); document.getElementById("totalScore").textContent = `åˆè¨ˆç‚¹æ•°: ${totalScore.toFixed(1)}`; isSorting = false; }
    
    // === è¡¨ç¤ºæ›´æ–°ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆ ===
    function updateDisplay() { /* çœç•¥ (å¤‰æ›´ãªã—) */ let allBelts = getSavedBelts(); let beltsWithScore = allBelts.map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) })); const filterRange = FILTERS[currentFilter]; let filteredBelts = beltsWithScore.filter(belt => filterRange && belt.score >= filterRange.min && belt.score <= filterRange.max); filteredBelts.sort((a, b) => currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score); renderSavedBelts(filteredBelts); updateActiveButtons(); }
    function updateActiveButtons() { /* çœç•¥ (å¤‰æ›´ãªã—) */ filterButtonGroup.querySelectorAll("button").forEach(btn => { btn.classList.toggle("active", btn.dataset.filter === currentFilter); }); sortButtonGroup.querySelectorAll("button").forEach(btn => { const sortType = btn.id; btn.classList.toggle("active", (sortType === "sortDivine" && currentSortDirection === "divine") || (sortType === "sortTrash" && currentSortDirection === "trash")); }); }
    function loadBelt(effects) { /* çœç•¥ (å¤‰æ›´ãªã—) */ const selects = container.querySelectorAll('select'); const searchInputs = container.querySelectorAll('.effect-search'); searchInputs.forEach(input => { input.value = ""; }); selects.forEach((select, index) => { select.value = effects[index] || 'åŠ¹æœãªã—'; }); updateAndSort(); window.scrollTo(0, 0); }
    
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ä¸€æ‹¬æ“ä½œé–¢é€£ã®é–¢æ•°â˜…â˜…â˜…
    function setupBulkActionButtons() {
        bulkActionsContainer.innerHTML = '';
        selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ';
        selectAllButton.addEventListener('click', toggleSelectAll);

        lockSelectedButton = document.createElement('button');
        lockSelectedButton.textContent = 'é¸æŠã‚’ãƒ­ãƒƒã‚¯';
        lockSelectedButton.addEventListener('click', lockSelectedBelts);

        // â˜…ã€Œé¸æŠã‚’è§£é™¤ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        unlockSelectedButton = document.createElement('button');
        unlockSelectedButton.textContent = 'é¸æŠã‚’ãƒ­ãƒƒã‚¯è§£é™¤';
        unlockSelectedButton.addEventListener('click', unlockSelectedBelts);

        deleteSelectedButton = document.createElement('button');
        deleteSelectedButton.textContent = 'é¸æŠã‚’å‰Šé™¤ï¼ˆãƒ­ãƒƒã‚¯ã‚’é™¤ãï¼‰';
        deleteSelectedButton.addEventListener('click', deleteSelectedBelts);
        
        lockAllButton = document.createElement('button');
        lockAllButton.textContent = 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯';
        lockAllButton.addEventListener('click', lockAllBelts);

        // â˜…ã€Œã™ã¹ã¦è§£é™¤ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        unlockAllButton = document.createElement('button');
        unlockAllButton.textContent = 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯è§£é™¤';
        unlockAllButton.addEventListener('click', unlockAllBelts);

        deleteAllUnlockedButton = document.createElement('button');
        deleteAllUnlockedButton.id = 'deleteAllUnlockedButton';
        deleteAllUnlockedButton.textContent = 'å…¨å‰Šé™¤(ãƒ­ãƒƒã‚¯é™¤ã)';
        deleteAllUnlockedButton.addEventListener('click', deleteAllUnlockedBelts);

        bulkActionsContainer.append(selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton);
    }

    function updateBulkActionButtonsState() {
        const selectedCount = savedBeltsList.querySelectorAll('.belt-selector:checked').length;
        const totalCount = savedBeltsList.querySelectorAll('.belt-selector').length;

        lockSelectedButton.disabled = selectedCount === 0;
        unlockSelectedButton.disabled = selectedCount === 0; // â˜…ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
        deleteSelectedButton.disabled = selectedCount === 0;

        if (totalCount === 0) {
            selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ';
            selectAllButton.disabled = true;
        } else {
            selectAllButton.disabled = false;
            if (selectedCount === 0) {
                selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ';
            } else if (selectedCount === totalCount) {
                selectAllButton.textContent = 'ã™ã¹ã¦è§£é™¤';
            } else {
                selectAllButton.textContent = `é¸æŠä¸­ ${selectedCount}`;
            }
        }
    }

    function toggleSelectAll() {
        const checkboxes = savedBeltsList.querySelectorAll('.belt-selector');
        const shouldSelectAll = Array.from(checkboxes).some(cb => !cb.checked);
        checkboxes.forEach(cb => {
            if (cb.checked !== shouldSelectAll) {
                cb.checked = shouldSelectAll;
                cb.closest('.saved-belt-item').classList.toggle('selected', shouldSelectAll);
            }
        });
        updateBulkActionButtonsState();
    }
    
    function getSelectedEffectsJson() {
        const checkedBoxes = savedBeltsList.querySelectorAll('.belt-selector:checked');
        return Array.from(checkedBoxes).map(cb => cb.dataset.effectsJson);
    }

    function lockSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        if (confirm(`é¸æŠã—ãŸ ${selectedEffects.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ`)) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if (selectedEffects.includes(JSON.stringify(belt.effects)) && !belt.locked) {
                    belt.locked = true;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`);
                updateDisplay();
            } else {
                showToast(`ãƒ­ãƒƒã‚¯å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
            }
        }
    }
    
    // â˜…ã€Œé¸æŠã‚’è§£é™¤ã€æ©Ÿèƒ½ã‚’è¿½åŠ 
    function unlockSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        if (confirm(`é¸æŠã—ãŸ ${selectedEffects.length} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if (selectedEffects.includes(JSON.stringify(belt.effects)) && belt.locked) {
                    belt.locked = false;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`);
                updateDisplay();
            } else {
                showToast(`ãƒ­ãƒƒã‚¯è§£é™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
            }
        }
    }

    function deleteSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        let savedBelts = getSavedBelts();
        const selectedBeltsData = savedBelts.filter(b => selectedEffects.includes(JSON.stringify(b.effects)));
        const unlockedToDelete = selectedBeltsData.filter(b => !b.locked);
        const lockedCount = selectedBeltsData.length - unlockedToDelete.length;

        if (unlockedToDelete.length === 0) {
            showToast('å‰Šé™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚(ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒ™ãƒ«ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“)');
            return;
        }

        let confirmMsg = `é¸æŠã—ãŸ ${unlockedToDelete.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
        if (lockedCount > 0) {
            confirmMsg += `\n\n(æ³¨æ„: ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ ${lockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“)`;
        }

        if (confirm(confirmMsg)) {
            const unlockedToDeleteSet = new Set(unlockedToDelete.map(b => JSON.stringify(b.effects)));
            const updatedBelts = savedBelts.filter(b => !unlockedToDeleteSet.has(JSON.stringify(b.effects)));
            localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts));
            showToast(`${unlockedToDelete.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
            updateDisplay();
        }
    }
    
    function lockAllBelts() {
        if(confirm('ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ')) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if(!belt.locked) {
                    belt.locked = true;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`);
                updateDisplay();
            } else {
                showToast('ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã¯æ—¢ã«ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚');
            }
        }
    }

    // â˜…ã€Œã™ã¹ã¦è§£é™¤ã€æ©Ÿèƒ½ã‚’è¿½åŠ 
    function unlockAllBelts() {
        if(confirm('ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if(belt.locked) {
                    belt.locked = false;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`);
                updateDisplay();
            } else {
                showToast('ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
            }
        }
    }

    function deleteAllUnlockedBelts() {
        let savedBelts = getSavedBelts();
        const unlockedCount = savedBelts.filter(b => !b.locked).length;

        if (unlockedCount === 0) {
            showToast('å‰Šé™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆ(ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ãƒ™ãƒ«ãƒˆ)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
            return;
        }

        if (confirm(`ã€å±é™ºã€‘ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ ${unlockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å…ƒã«æˆ»ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ï¼`)) {
            const confirmationText = 'delete';
            const userInput = prompt(`æœ¬å½“ã«å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ã€Œ${confirmationText}ã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`);
            if (userInput === confirmationText) {
                const updatedBelts = savedBelts.filter(b => b.locked);
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts));
                showToast(`ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ ${unlockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
                updateDisplay();
            } else {
                showToast('å…¥åŠ›ãŒä¸€è‡´ã—ãªã‹ã£ãŸãŸã‚ã€å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚');
            }
        }
    }


    // === åˆæœŸåŒ–å‡¦ç† ===
    function generateSealableGroups() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const groups = new Map(); function addGroup(name, score) { const key = name.replace(/\+\?%?/, '').trim(); if (!groups.has(key)) { groups.set(key, { group: name, score: score }); } } addGroup("ã“ã†ã’ãåŠ›+?", ALL_EFFECTS_DATA["ã“ã†ã’ãåŠ›+25"]); addGroup("ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+?", ALL_EFFECTS_DATA["ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50"]); addGroup("ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+?%", ALL_EFFECTS_DATA["ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%"]); WEAPON_NAMES.forEach(weapon => { const baseScore = WEAPON_EFFECTS[weapon]; ELEMENTS.forEach(element => { addGroup(`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, baseScore + 3); }); }); Object.keys(MONSTER_TYPES).forEach(type => { const baseScore = MONSTER_TYPES[type]; addGroup(`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, baseScore + 3); }); addGroup("ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»", ALL_EFFECTS_DATA["ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»"]); const sortedGroups = Array.from(groups.values()).sort((a, b) => { if (b.score !== a.score) return b.score - a.score; return a.group.localeCompare(b.group, 'ja'); }); sealableGroups = sortedGroups.map(g => g.group); }
    function createEffectSelects() { /* çœç•¥ (å¤‰æ›´ãªã—) */ const labels = ["ã‚«ãƒ†ã‚´ãƒªãƒ¼", "åŠ¹æœ 1", "åŠ¹æœ 2", "åŠ¹æœ 3", "åŠ¹æœ 4", "åŠ¹æœ 5"]; labels.forEach((labelText, index) => { const block = document.createElement("div"); block.className = "effect-block"; const label = document.createElement("label"); label.textContent = labelText; const searchInput = document.createElement("input"); searchInput.type = "text"; searchInput.className = "effect-search"; searchInput.placeholder = "åŠ¹æœã‚’æ¤œç´¢ã—ã¦çµã‚Šè¾¼ã¿..."; const select = document.createElement("select"); select.dataset.type = index === 0 ? "category" : "effect"; select.addEventListener("change", updateAndSort); searchInput.addEventListener("input", updateAndSort); block.appendChild(label); block.appendChild(searchInput); block.appendChild(select); container.appendChild(block); }); rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.appendChild(sourceFragment.cloneNode(true)); }); }
    function createFilterButtons() { /* çœç•¥ (å¤‰æ›´ãªã—) */ filterButtonGroup.innerHTML = ""; const filterConfigs = [ { filter: "all", text: "ã™ã¹ã¦è¡¨ç¤º" }, { filter: "general", text: "æ±ç”¨ãƒ™ãƒ«ãƒˆ" }, ...WEAPON_NAMES.map(name => ({ filter: name, text: `${name}ç”¨` })), { filter: "pending", text: "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ" }, { filter: "storage", text: "å–ã‚Šæ•¢ãˆãšåç´" } ]; filterConfigs.forEach(({ filter, text }) => { const button = document.createElement("button"); button.dataset.filter = filter; button.textContent = text; button.addEventListener("click", () => { currentFilter = button.dataset.filter; updateDisplay(); }); filterButtonGroup.appendChild(button); }); }

    document.addEventListener('DOMContentLoaded', () => {
        migrateSavedBelts();
        generateSealableGroups();
        createEffectSelects();
        createFilterButtons();
        setupBulkActionButtons();
        updateAndSort();
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', (e) => { if (e.target === sealModal) sealModal.style.display = 'none'; });
        updateDisplay();
    });
  </script>
</body>
</html>

