<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ« å†ä¿®æ­£(ver1.8.3 UIæ”¹å–„ç‰ˆ)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* åˆè¨ˆç‚¹æ•°ã‚’éè¡¨ç¤ºã« */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; align-items: center; gap: 12px; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-item.selected { background-color: #e6f7ff; border-left-color: #007bff; }
    .belt-selector { flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .action-button-group button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.7; }

    /* â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šUIæ”¹å–„ã®ãŸã‚ã€ãƒœã‚¿ãƒ³ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ â˜…â˜…â˜… */
    fieldset {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px 15px 15px 15px; /* ä¸Šã€å·¦å³ã€ä¸‹ */
      margin-bottom: 15px;
      background-color: #fafafa;
    }
    legend {
      font-weight: bold;
      font-size: 0.9em;
      padding: 0 8px;
      color: #333;
    }
    #bulkActionsContainer {
        border-bottom: none;
        padding-bottom: 0;
    }
    .action-button-group {
        margin-top: 5px; /* legendã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
    }
    /* â˜…â˜…â˜…å¤‰æ›´ç‚¹ã“ã“ã¾ã§â˜…â˜…â˜… */


    #deleteAllUnlockedButton { background-color: #c82333; color: white; border-color: #c82333; }
    #deleteAllUnlockedButton:hover { background-color: #a71d2a; }

    /* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã”ã¨ã®è‰²ã‚’å®šç¾© */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; }

    /* å°å°è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ«</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">åˆè¨ˆç‚¹æ•°: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">å°å°åŠ¹æœã®ç®¡ç†</button>
    <button id="saveButton">ç¾åœ¨ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜</button>
  </div>

  <div id="savedBeltsSection">
    <h2>ä¿å­˜ã•ã‚ŒãŸãƒ™ãƒ«ãƒˆ<span id="savedBeltsCount"></span></h2>

    <fieldset>
      <legend>ä¸€æ‹¬æ“ä½œ</legend>
      <div id="bulkActionsContainer" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>çµã‚Šè¾¼ã¿</legend>
      <div id="filterButtonGroup" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>ä¸¦ã³æ›¿ãˆ</legend>
      <div class="action-button-group" id="sortButtonGroup">
        <button id="sortDivine">ç¥ãƒ™ãƒ«ãƒˆé †</button>
        <button id="sortTrash">ã‚´ãƒŸãƒ™ãƒ«ãƒˆé †</button>
      </div>
    </fieldset>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>å°å°åŠ¹æœã®ç®¡ç†</span><span id="sealedCount"></span></h2>
        <p>å°å°ã—ãŸã„åŠ¹æœã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚ãƒã‚§ãƒƒã‚¯ã—ãŸåŠ¹æœã¯ã€åŠ¹æœé¸æŠã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¡¨ç¤ºã•ã‚Œãªããªã‚Šã¾ã™ã€‚é¸æŠå¾Œã€ä¿å­˜ã™ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="saveSealSettingsButton">ä¿å­˜ã™ã‚‹</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // å…¨ä½“ã‚’å³æ™‚å®Ÿè¡Œé–¢æ•°(IIFE)ã§å›²ã¿ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®æ±šæŸ“ã‚’é˜²ã
    (function() {
        'use strict';

        // === å®šæ•°å®šç¾© ===
        const CONSTANTS = {
            DATA_VERSION: '1.8.3.opt',
            KEYS: {
                SAVED_BELTS: 'savedBelts',
                DATA_VERSION: 'savedBeltsVersion',
                SEALED_EFFECTS: 'sealedEffects',
            },
            EFFECT_TYPES: {
                CATEGORY: 'category',
                EFFECT: 'effect',
            },
            DEFAULT_EFFECT: 'åŠ¹æœãªã—',
            DEBOUNCE_DELAY: 250,
        };

        const WEAPON_EFFECTS = { "å³æ‰‹ã«ç‰‡æ‰‹å‰£": 18, "ä¸¡æ‰‹å‰£": 17.9, "å³æ‰‹ã«çŸ­å‰£": 17.8, "å³æ‰‹ã«ã‚¹ãƒ†ã‚£ãƒƒã‚¯": 17.7, "ä¸¡æ‰‹æ–": 17.6, "ãƒ¤ãƒª": 17.5, "ã‚ªãƒ": 17.4, "æ£": 17.3, "ãƒ„ãƒ¡": 17.2, "ãƒ ãƒ": 17.1, "å³æ‰‹ã«æ‰‡": 17.0, "å³æ‰‹ã«ãƒãƒ³ãƒãƒ¼": 16.9, "å³æ‰‹ã«ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³": 16.8, "å¼“": 16.7, "éŒ": 16.6 };
        const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
        const WEAPON_NAMES_FOR_CATEGORY = ["ç‰‡æ‰‹å‰£", "ä¸¡æ‰‹å‰£", "çŸ­å‰£", "ã‚¹ãƒ†ã‚£ãƒƒã‚¯", "ä¸¡æ‰‹æ–", "ãƒ¤ãƒª", "ã‚ªãƒ", "æ£", "ãƒ„ãƒ¡", "ãƒ ãƒ", "æ‰‡", "ãƒãƒ³ãƒãƒ¼", "ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³", "å¼“", "éŒ"];
        const ELEMENTS = ["ç‚", "æ°·", "é¢¨", "é›·", "åœŸ", "é—‡", "å…‰"];
        const MONSTER_TYPES = { "ãƒ‰ãƒ©ã‚´ãƒ³ç³»": 16.5, "è™«ç³»": 16.4, "ç£ç³»": 16.3, "ã‚¾ãƒ³ãƒ“ç³»": 16.2, "æ¤ç‰©ç³»": 16.1, "æ€ªäººç³»": 16.0, "æ‚ªé­”ç³»": 15.9, "ã‚¨ãƒ¬ç³»": 15.8, "é³¥ç³»": 15.7, "ç‰©è³ªç³»": 15.6, "ã‚¹ãƒ©ã‚¤ãƒ ç³»": 15.5, "ãƒã‚·ãƒ³ç³»": 15.4, "æ°´ç³»": 15.3 };
        
        const ALL_EFFECTS_DATA = createAllEffectsData();
        const FILTERS = createFilters();

        // === ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ç®¡ç† ===
        const AppState = {
            currentFilter: 'all',
            currentSortDirection: 'divine',
            isUpdatingSelectors: false,
            debounceTimer: null,
            sealableGroups: [],
            groupKeyDataMap: new Map(),
            fullOptionsFragment: document.createDocumentFragment(),
            categoryOptionsFragment: document.createDocumentFragment(),
            effectOptionsFragment: document.createDocumentFragment(),
        };

        // === DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ ===
        const DOM = {
            container: document.getElementById('effectsContainer'),
            savedBeltsList: document.getElementById('savedBeltsList'),
            saveButton: document.getElementById('saveButton'),
            sortDivineButton: document.getElementById('sortDivine'),
            sortTrashButton: document.getElementById('sortTrash'),
            savedBeltsCountElement: document.getElementById('savedBeltsCount'),
            filterButtonGroup: document.getElementById('filterButtonGroup'),
            sortButtonGroup: document.getElementById('sortButtonGroup'),
            sealSettingsButton: document.getElementById('sealSettingsButton'),
            sealModal: document.getElementById('sealModal'),
            sealActionButtonsContainer: document.getElementById('sealActionButtons'),
            sealGroupsContainer: document.getElementById('sealGroupsContainer'),
            saveSealSettingsButton: document.getElementById('saveSealSettingsButton'),
            cancelSealSettingsButton: document.getElementById('cancelSealSettingsButton'),
            sealedCountElement: document.getElementById('sealedCount'),
            toastContainer: document.getElementById('toast-container'),
            bulkActionsContainer: document.getElementById('bulkActionsContainer'),
            totalScore: document.getElementById('totalScore'),
        };
        // ä¸€æ‹¬æ“ä½œãƒœã‚¿ãƒ³ã¯å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€å¾Œã§å‚ç…§ã‚’æ ¼ç´
        let bulkActionButtons = {};

        // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ===
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(AppState.debounceTimer);
                AppState.debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }
        const debouncedUpdateEffectSelectors = debounce(updateEffectSelectors, CONSTANTS.DEBOUNCE_DELAY);
        function showToast(message) { const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = message; DOM.toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
        function getSavedBelts() { const beltsJSON = localStorage.getItem(CONSTANTS.KEYS.SAVED_BELTS); return beltsJSON ? JSON.parse(beltsJSON) : []; }
        function calculateTotalScore(effects) { return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0); }
        function getGroupKeyForEffect(effect) { if (!effect || effect === CONSTANTS.DEFAULT_EFFECT || effect.includes('(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)')) { return null; } const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim(); return (key && key !== effect) ? key : effect; }

        // === ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆé–¢æ•° ===
        function createAllEffectsData() {
            const categoryScores = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 40000, "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 6000, "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 4000 };
            let weaponScore = 38000;
            WEAPON_NAMES_FOR_CATEGORY.forEach(name => { categoryScores[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = weaponScore; weaponScore -= 2000; });
            const effectScores = { "åŠ¹æœãªã—": -30, "ã“ã†ã’ãåŠ›+15": 15, "ã“ã†ã’ãåŠ›+20": 21.8, "ã“ã†ã’ãåŠ›+25": 22, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+30": 14.9, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+40": 21.7, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50": 21.9, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.0%": 14.8, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.5%": 21.7, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%": 21.8, "ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»": 0.05 };
            Object.keys(WEAPON_EFFECTS).forEach(weapon => { const baseScore = WEAPON_EFFECTS[weapon]; ELEMENTS.forEach(element => { [12, 13, 14, 15].forEach(val => { effectScores[`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+${val}%`] = baseScore + (val - 12); }); }); });
            Object.keys(MONSTER_TYPES).forEach(type => { const baseScore = MONSTER_TYPES[type]; for(let i = 0; i < 4; i++) { effectScores[`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+${9+i}%`] = baseScore + i; } });
            return { ...categoryScores, ...effectScores };
        }
        function createFilters() {
            const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } };
            let weaponScore = 38000;
            WEAPON_NAMES_FOR_CATEGORY.forEach(name => { const minScore = weaponScore - 2000; filters[name] = { min: minScore + 1849, max: weaponScore + 1848 }; weaponScore -= 2000; });
            return filters;
        }

        // === å°å°æ©Ÿèƒ½é–¢é€£ ===
        function getSealedGroups() { return localStorage.getItem(CONSTANTS.KEYS.SEALED_EFFECTS) ? JSON.parse(localStorage.getItem(CONSTANTS.KEYS.SEALED_EFFECTS)) : []; }
        function isEffectSealed(effect, sealedGroups) { if (!sealedGroups || sealedGroups.length === 0) return false; const groupKey = getGroupKeyForEffect(effect); if (groupKey) { return sealedGroups.some(g => g.startsWith(groupKey)); } return sealedGroups.some(groupPrefix => effect.startsWith(groupPrefix.replace(/\+\?%?/, '').replace("â—‹â—‹ç³»", ""))); }
        function updateSealedCount() { if (!AppState.sealableGroups || AppState.sealableGroups.length === 0) return; const checkedCount = DOM.sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length; const totalCount = AppState.sealableGroups.length; DOM.sealedCountElement.textContent = `(${checkedCount} / ${totalCount} ä»¶ å°å°ä¸­)`; }
        function populateSealModal() { DOM.sealActionButtonsContainer.innerHTML = ''; const selectAllButton = document.createElement('button'); selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ'; selectAllButton.addEventListener('click', () => { DOM.sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); }); const deselectAllButton = document.createElement('button'); deselectAllButton.textContent = 'ã™ã¹ã¦è§£é™¤'; deselectAllButton.addEventListener('click', () => { DOM.sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); }); DOM.sealActionButtonsContainer.append(selectAllButton, deselectAllButton); DOM.sealGroupsContainer.innerHTML = ''; const sealedGroups = getSealedGroups(); AppState.sealableGroups.forEach(group => { const div = document.createElement('div'); div.className = 'seal-group'; const label = document.createElement('label'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group); checkbox.addEventListener('change', updateSealedCount); label.append(checkbox, document.createTextNode(group)); div.appendChild(label); DOM.sealGroupsContainer.appendChild(div); }); updateSealedCount(); }
        function saveSealSettings() { const checkboxes = DOM.sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked'); const sealedGroups = Array.from(checkboxes).map(cb => cb.value); localStorage.setItem(CONSTANTS.KEYS.SEALED_EFFECTS, JSON.stringify(sealedGroups)); DOM.sealModal.style.display = 'none'; updateAllSelectOptions(); showToast("å°å°è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚"); }

        // === ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç† (ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³/ä¿å­˜/å‰Šé™¤/æ›´æ–°) ===
        function migrateSavedBelts() {
            const storedVersion = localStorage.getItem(CONSTANTS.KEYS.DATA_VERSION);
            if (storedVersion === CONSTANTS.DATA_VERSION) return;
            let savedBelts = getSavedBelts();
            const migratedBelts = savedBelts.map(belt => {
                let currentBelt = belt;
                if (Array.isArray(currentBelt)) currentBelt = { effects: currentBelt, locked: false, memo: '' };
                if (typeof currentBelt !== 'object' || currentBelt === null || !Array.isArray(currentBelt.effects)) return null;
                const newEffects = currentBelt.effects.map(effect => {
                    let newEffect = effect;
                    newEffect = newEffect.replace(/^å³æ‰‹ã«(ç‰‡æ‰‹å‰£|çŸ­å‰£|ã‚¹ãƒ†ã‚£ãƒƒã‚¯|æ‰‡|ãƒãƒ³ãƒãƒ¼|ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³)ç”¨ãƒ™ãƒ«ãƒˆ/, '$1ç”¨ãƒ™ãƒ«ãƒˆ');
                    newEffect = newEffect.replace(/^(ç‰‡æ‰‹å‰£|çŸ­å‰£|ã‚¹ãƒ†ã‚£ãƒƒã‚¯|æ‰‡|ãƒãƒ³ãƒãƒ¼|ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³)è£…å‚™æ™‚/, 'å³æ‰‹ã«$1è£…å‚™æ™‚');
                    return newEffect;
                });
                return { effects: newEffects, locked: currentBelt.locked === true, memo: currentBelt.memo || '' };
            }).filter(Boolean);
            localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(migratedBelts));
            localStorage.setItem(CONSTANTS.KEYS.DATA_VERSION, CONSTANTS.DATA_VERSION);
            console.log("ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ver " + CONSTANTS.DATA_VERSION + " ã«æ›´æ–°ã—ã¾ã—ãŸã€‚");
            showToast("ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æœ€æ–°ç‰ˆã«æ›´æ–°ã—ã¾ã—ãŸã€‚");
        }
        function saveCurrentBelt() {
            const currentEffects = Array.from(DOM.container.querySelectorAll('select')).map(s => s.value);
            if (currentEffects.slice(1).filter(e => e !== CONSTANTS.DEFAULT_EFFECT).length < 1) { showToast("æœ‰åŠ¹ãªåŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚"); return; }
            const savedBelts = getSavedBelts();
            const newBeltData = { effects: currentEffects, locked: false, memo: '' };
            if (savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects))) { showToast("ã“ã®åŠ¹æœã®çµ„ã¿åˆã‚ã›ã¯æ—¢ã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"); return; }
            const newBeltEffectGroups = new Set(currentEffects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
            if (newBeltEffectGroups.size > 0) {
                let mostSimilar = { count: 0, groups: [] };
                for (const savedBelt of savedBelts) {
                    const existingBeltEffectGroups = new Set(savedBelt.effects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
                    const intersection = new Set([...newBeltEffectGroups].filter(group => existingBeltEffectGroups.has(group)));
                    if (intersection.size > mostSimilar.count) mostSimilar = { count: intersection.size, groups: [...intersection] };
                }
                if (mostSimilar.count >= 2) {
                    const displayName = mostSimilar.groups.map(key => AppState.groupKeyDataMap.get(key)?.group || key).join('\n');
                    if (!confirm(`åŠ¹æœãŒ${mostSimilar.count}ã¤é‡è¤‡ã™ã‚‹ãƒ™ãƒ«ãƒˆã‚’æ‰€æœ‰ã—ã¦ã„ã¾ã™ã€‚\n\nåŠ¹æœå†…å®¹\n${displayName}\n\nãã‚Œã§ã‚‚ã“ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ`)) { showToast("ä¿å­˜ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚"); return; }
                }
            }
            savedBelts.push(newBeltData);
            localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(savedBelts));
            showToast("ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸï¼");
            updateDisplay();
        }
        function deleteBelt(effectsToDelete) { if (!confirm("ã“ã®ãƒ™ãƒ«ãƒˆã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; let savedBelts = getSavedBelts(); const effectsToDeleteStr = JSON.stringify(effectsToDelete); const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr); localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(updatedBelts)); showToast("ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); }
        function editMemo(effectsToEdit) { let savedBelts = getSavedBelts(); const effectsToEditStr = JSON.stringify(effectsToEdit); const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr); if (beltToEdit) { const newMemo = prompt("ãƒ™ãƒ«ãƒˆã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", beltToEdit.memo || ""); if (newMemo !== null) { beltToEdit.memo = newMemo.trim(); localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(savedBelts)); showToast("ãƒ¡ãƒ¢ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚"); updateDisplay(); } } }
        function toggleLockState(effectsToToggle) { let savedBelts = getSavedBelts(); const effectsToToggleStr = JSON.stringify(effectsToToggle); const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr); if (beltToToggle) { beltToToggle.locked = !beltToToggle.locked; localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(savedBelts)); showToast(beltToToggle.locked ? "ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚" : "ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); } }

        // === è¡¨ç¤ºé–¢é€£ ===
        function renderSavedBelts(beltsToRender) {
            DOM.savedBeltsList.innerHTML = '';
            DOM.savedBeltsCountElement.textContent = `(è¡¨ç¤º: ${beltsToRender.length}å€‹ / åˆè¨ˆ: ${getSavedBelts().length}å€‹)`;
            const categoryClassMap = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-general", "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-pending", "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-storage", ...Object.fromEntries(WEAPON_NAMES_FOR_CATEGORY.map((name, index) => [`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`, `category-weapon-${index}`])) };
            if (beltsToRender.length === 0) {
                const noBeltMessage = document.createElement('p');
                noBeltMessage.textContent = 'è¡¨ç¤ºå¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
                noBeltMessage.style.textAlign = 'center'; noBeltMessage.style.color = '#888';
                DOM.savedBeltsList.appendChild(noBeltMessage);
            } else {
                const fragment = document.createDocumentFragment();
                beltsToRender.forEach(({ effects, locked, memo }) => {
                    const beltItem = document.createElement('div');
                    beltItem.className = `saved-belt-item ${categoryClassMap[effects[0]] || 'category-default'}`;
                    const validEffects = effects.filter(e => e !== CONSTANTS.DEFAULT_EFFECT);
                    const memoHtml = memo ? `<span class="belt-memo">ğŸ“ ${memo}</span>` : '';
                    beltItem.innerHTML = `
                        <input type="checkbox" class="belt-selector" data-effects-json='${JSON.stringify(effects)}'>
                        <div class="saved-belt-info" data-action="load">
                            ${validEffects.map(e => `<span>${e}</span>`).join('')}
                            ${memoHtml}
                        </div>
                        <div class="saved-belt-actions">
                            <div class="saved-belt-actions-upper">
                                <button class="saved-belt-lock" data-action="lock">${locked ? 'è§£é™¤' : 'ãƒ­ãƒƒã‚¯'}</button>
                                <button class="saved-belt-delete" data-action="delete" ${locked ? 'disabled' : ''}>å‰Šé™¤</button>
                            </div>
                            <button class="saved-belt-memo-edit" data-action="memo">ãƒ¡ãƒ¢ç·¨é›†</button>
                        </div>`;
                    fragment.appendChild(beltItem);
                });
                DOM.savedBeltsList.appendChild(fragment);
            }
            updateBulkActionButtonsState();
        }

        // === ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã®ç”Ÿæˆãƒ»æ›´æ–° ===
        function rebuildOptionFragments() {
            AppState.fullOptionsFragment = document.createDocumentFragment();
            AppState.categoryOptionsFragment = document.createDocumentFragment();
            AppState.effectOptionsFragment = document.createDocumentFragment();
            const sealedGroups = getSealedGroups();
            for (const effectName in ALL_EFFECTS_DATA) {
                if (isEffectSealed(effectName, sealedGroups)) continue;
                const option = document.createElement("option");
                option.value = effectName;
                option.textContent = effectName;
                AppState.fullOptionsFragment.appendChild(option.cloneNode(true));
                if (effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === CONSTANTS.DEFAULT_EFFECT) { AppState.categoryOptionsFragment.appendChild(option.cloneNode(true)); }
                if (!effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === CONSTANTS.DEFAULT_EFFECT) { AppState.effectOptionsFragment.appendChild(option.cloneNode(true)); }
            }
        }
        function updateAllSelectOptions() { rebuildOptionFragments(); debouncedUpdateEffectSelectors(); }

        // === ã‚»ãƒ¬ã‚¯ã‚¿æ›´æ–°ã®ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ ===
        function updateEffectSelectors() {
            if (AppState.isUpdatingSelectors) return;
            AppState.isUpdatingSelectors = true;
            const allSelects = Array.from(DOM.container.querySelectorAll('select'));
            const searchInputs = Array.from(DOM.container.querySelectorAll('.effect-search'));
            const currentValues = allSelects.map(s => s.value);
            const categoryValue = currentValues[0];
            const sortedEffects = [...currentValues.slice(1)].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));
            const finalValues = [categoryValue, ...sortedEffects];
            allSelects.forEach((select, index) => updateSingleSelect(select, index, finalValues, searchInputs[index].value.toLowerCase()));
            DOM.totalScore.textContent = `åˆè¨ˆç‚¹æ•°: ${calculateTotalScore(finalValues).toFixed(1)}`;
            AppState.isUpdatingSelectors = false;
        }
        function updateSingleSelect(select, currentIndex, finalValues, searchTerm) {
            const finalValueForThisSelect = finalValues[currentIndex];
            const otherUsedGroupKeys = new Set(finalValues.map((v, i) => i !== currentIndex && v !== CONSTANTS.DEFAULT_EFFECT ? getGroupKeyForEffect(v) : null).filter(Boolean));
            const sourceFragment = select.dataset.type === CONSTANTS.EFFECT_TYPES.CATEGORY ? AppState.categoryOptionsFragment : AppState.effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();
            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === finalValueForThisSelect;
                const matchesSearch = !searchTerm || optionNode.textContent.toLowerCase().includes(searchTerm);
                if (isSelectableByGroup && matchesSearch) newOptionsFragment.appendChild(optionNode.cloneNode(true));
            });
            select.innerHTML = '';
            select.appendChild(newOptionsFragment);
            if (!Array.from(select.options).some(opt => opt.value === finalValueForThisSelect) && finalValueForThisSelect !== CONSTANTS.DEFAULT_EFFECT) {
                const restoredOption = document.createElement('option');
                restoredOption.value = finalValueForThisSelect;
                restoredOption.textContent = finalValueForThisSelect;
                select.insertBefore(restoredOption, select.firstChild);
            }
            select.value = finalValueForThisSelect;
        }

        // === è¡¨ç¤ºæ›´æ–°ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆ ===
        function updateDisplay() {
            const allBelts = getSavedBelts().map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) }));
            const filterRange = FILTERS[AppState.currentFilter];
            let filteredBelts = filterRange ? allBelts.filter(belt => belt.score >= filterRange.min && belt.score <= filterRange.max) : allBelts;
            filteredBelts.sort((a, b) => AppState.currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score);
            renderSavedBelts(filteredBelts);
            updateActiveButtons();
        }
        function updateActiveButtons() {
            DOM.filterButtonGroup.querySelectorAll("button").forEach(btn => btn.classList.toggle("active", btn.dataset.filter === AppState.currentFilter));
            DOM.sortButtonGroup.querySelectorAll("button").forEach(btn => {
                const isDivineActive = btn.id === "sortDivine" && AppState.currentSortDirection === "divine";
                const isTrashActive = btn.id === "sortTrash" && AppState.currentSortDirection === "trash";
                btn.classList.toggle("active", isDivineActive || isTrashActive);
            });
        }
        function loadBelt(effects) {
            DOM.container.querySelectorAll('.effect-search').forEach(input => { input.value = ""; });
            DOM.container.querySelectorAll('select').forEach((select, index) => { select.value = effects[index] || CONSTANTS.DEFAULT_EFFECT; });
            debouncedUpdateEffectSelectors();
            window.scrollTo(0, 0);
        }

        // === ä¸€æ‹¬æ“ä½œé–¢é€£ ===
        function setupBulkActionButtons() {
            DOM.bulkActionsContainer.innerHTML = '';
            const buttons = {
                selectAll: { text: 'ã™ã¹ã¦é¸æŠ', handler: toggleSelectAll },
                lockSelected: { text: 'é¸æŠã‚’ãƒ­ãƒƒã‚¯', handler: lockSelectedBelts },
                unlockSelected: { text: 'é¸æŠã‚’ãƒ­ãƒƒã‚¯è§£é™¤', handler: unlockSelectedBelts },
                deleteSelected: { text: 'é¸æŠã‚’å‰Šé™¤ï¼ˆãƒ­ãƒƒã‚¯ã‚’é™¤ãï¼‰', handler: deleteSelectedBelts },
                lockAll: { text: 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯', handler: lockAllBelts },
                unlockAll: { text: 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯è§£é™¤', handler: unlockAllBelts },
                deleteAllUnlocked: { id: 'deleteAllUnlockedButton', text: 'å…¨å‰Šé™¤(ãƒ­ãƒƒã‚¯é™¤ã)', handler: deleteAllUnlockedBelts },
            };
            for (const key in buttons) {
                const btnConfig = buttons[key];
                const button = document.createElement('button');
                button.textContent = btnConfig.text;
                if (btnConfig.id) button.id = btnConfig.id;
                button.addEventListener('click', btnConfig.handler);
                bulkActionButtons[key] = button;
                DOM.bulkActionsContainer.appendChild(button);
            }
        }
        function updateBulkActionButtonsState() {
            const selectedCount = DOM.savedBeltsList.querySelectorAll('.belt-selector:checked').length;
            const totalCount = DOM.savedBeltsList.querySelectorAll('.belt-selector').length;
            const hasSelection = selectedCount > 0;
            bulkActionButtons.lockSelected.disabled = !hasSelection;
            bulkActionButtons.unlockSelected.disabled = !hasSelection;
            bulkActionButtons.deleteSelected.disabled = !hasSelection;
            bulkActionButtons.selectAll.disabled = totalCount === 0;
            if (totalCount === 0) { bulkActionButtons.selectAll.textContent = 'ã™ã¹ã¦é¸æŠ'; }
            else { bulkActionButtons.selectAll.textContent = selectedCount === totalCount ? 'ã™ã¹ã¦è§£é™¤' : (selectedCount > 0 ? `é¸æŠä¸­ ${selectedCount}`: 'ã™ã¹ã¦é¸æŠ'); }
        }
        function toggleSelectAll() {
            const checkboxes = DOM.savedBeltsList.querySelectorAll('.belt-selector');
            const shouldSelectAll = Array.from(checkboxes).some(cb => !cb.checked);
            checkboxes.forEach(cb => {
                const item = cb.closest('.saved-belt-item');
                if (cb.checked !== shouldSelectAll) { cb.checked = shouldSelectAll; item.classList.toggle('selected', shouldSelectAll); }
            });
            updateBulkActionButtonsState();
        }
        function getSelectedEffectsJson() { return Array.from(DOM.savedBeltsList.querySelectorAll('.belt-selector:checked')).map(cb => cb.dataset.effectsJson); }
        function operateOnBelts(operation, filterCondition, confirmMsg, successMsg, failMsg) {
            let savedBelts = getSavedBelts();
            const targetBelts = savedBelts.filter(filterCondition);
            if (targetBelts.length === 0) { showToast(failMsg); return; }
            if (confirm(confirmMsg(targetBelts.length))) {
                let changedCount = 0;
                savedBelts.forEach(belt => { if (filterCondition(belt) && operation(belt)) changedCount++; });
                if (changedCount > 0) { localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(savedBelts)); showToast(successMsg(changedCount)); updateDisplay(); }
                else { showToast(failMsg); }
            }
        }
        function lockSelectedBelts() { const selected = new Set(getSelectedEffectsJson()); operateOnBelts(b => { if(!b.locked) { b.locked=true; return true; } return false; }, b => selected.has(JSON.stringify(b.effects)), c => `é¸æŠã—ãŸ${c}å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ`, c => `${c}å€‹ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`, 'ãƒ­ãƒƒã‚¯å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
        function unlockSelectedBelts() { const selected = new Set(getSelectedEffectsJson()); operateOnBelts(b => { if(b.locked) { b.locked=false; return true; } return false; }, b => selected.has(JSON.stringify(b.effects)), c => `é¸æŠã—ãŸ${c}å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ`, c => `${c}å€‹è§£é™¤ã—ã¾ã—ãŸã€‚`, 'ãƒ­ãƒƒã‚¯è§£é™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
        function deleteSelectedBelts() { const selectedJson = getSelectedEffectsJson(); if (selectedJson.length === 0) { showToast('å‰Šé™¤ã™ã‚‹ãƒ™ãƒ«ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); return; } let savedBelts = getSavedBelts(); const selectedSet = new Set(selectedJson); const unlockedToDelete = savedBelts.filter(b => selectedSet.has(JSON.stringify(b.effects)) && !b.locked); const lockedCount = selectedJson.length - unlockedToDelete.length; if (unlockedToDelete.length === 0) { showToast('å‰Šé™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚(ãƒ­ãƒƒã‚¯ä¸­ã¯å‰Šé™¤ä¸å¯)'); return; } let confirmMsg = `é¸æŠã—ãŸ${unlockedToDelete.length}å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`; if (lockedCount > 0) { confirmMsg += `\n\n(æ³¨æ„: ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹${lockedCount}å€‹ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“)`; } if (confirm(confirmMsg)) { const toDeleteEffects = new Set(unlockedToDelete.map(b => JSON.stringify(b.effects))); const updatedBelts = savedBelts.filter(b => !toDeleteEffects.has(JSON.stringify(b.effects))); localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(updatedBelts)); showToast(`${unlockedToDelete.length}å€‹å‰Šé™¤ã—ã¾ã—ãŸã€‚`); updateDisplay(); } }
        function lockAllBelts() { operateOnBelts(b => { if(!b.locked){b.locked=true; return true;} return false;}, () => true, c => `ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆ(${c}å€‹)ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ`, c => `${c}å€‹ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`, 'å…¨ãƒ™ãƒ«ãƒˆãŒãƒ­ãƒƒã‚¯æ¸ˆã¿ã§ã™ã€‚'); }
        function unlockAllBelts() { operateOnBelts(b => { if(b.locked){b.locked=false; return true;} return false;}, () => true, c => `ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆ(${c}å€‹)ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ`, c => `${c}å€‹è§£é™¤ã—ã¾ã—ãŸã€‚`, 'ãƒ­ãƒƒã‚¯ä¸­ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
        function deleteAllUnlockedBelts() { const savedBelts = getSavedBelts(); const unlockedCount = savedBelts.filter(b => !b.locked).length; if (unlockedCount === 0) { showToast('å‰Šé™¤å¯¾è±¡(ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ãƒ™ãƒ«ãƒˆ)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; } if (confirm(`ã€å±é™ºã€‘ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„${unlockedCount}å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼`)) { const userInput = prompt(`æœ¬å½“ã«å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ã€Œdeleteã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`); if (userInput === 'delete') { const updatedBelts = savedBelts.filter(b => b.locked); localStorage.setItem(CONSTANTS.KEYS.SAVED_BELTS, JSON.stringify(updatedBelts)); showToast(`ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„${unlockedCount}å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`); updateDisplay(); } else { showToast('å…¥åŠ›ãŒä¸€è‡´ã›ãšã€å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚'); } } }

        // === åˆæœŸåŒ–å‡¦ç† ===
        function generateSealableGroups() { AppState.groupKeyDataMap.clear(); function addGroup(name, score) { const key = name.replace(/\+\?%?/, '').trim(); if (!AppState.groupKeyDataMap.has(key)) AppState.groupKeyDataMap.set(key, { group: name, score: score }); } addGroup("ã“ã†ã’ãåŠ›+?", 22); addGroup("ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+?", 21.9); addGroup("ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+?%", 21.8); WEAPON_NAMES.forEach(weapon => ELEMENTS.forEach(element => addGroup(`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, WEAPON_EFFECTS[weapon] + 3))); Object.keys(MONSTER_TYPES).forEach(type => addGroup(`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, MONSTER_TYPES[type] + 3)); addGroup("ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»", 0.05); AppState.sealableGroups = Array.from(AppState.groupKeyDataMap.values()).sort((a, b) => b.score - a.score || a.group.localeCompare(b.group, 'ja')).map(g => g.group); }
        function createEffectSelects() { ['ã‚«ãƒ†ã‚´ãƒªãƒ¼', 'åŠ¹æœ 1', 'åŠ¹æœ 2', 'åŠ¹æœ 3', 'åŠ¹æœ 4', 'åŠ¹æœ 5'].forEach((labelText, index) => { const block = document.createElement("div"); block.className = "effect-block"; block.innerHTML = `<label>${labelText}</label><input type="text" class="effect-search" placeholder="åŠ¹æœã‚’æ¤œç´¢ã—ã¦çµã‚Šè¾¼ã¿..."><select data-type="${index === 0 ? CONSTANTS.EFFECT_TYPES.CATEGORY : CONSTANTS.EFFECT_TYPES.EFFECT}"></select>`; DOM.container.appendChild(block); }); }
        function createFilterButtons() { DOM.filterButtonGroup.innerHTML = ''; [{ filter: "all", text: "ã™ã¹ã¦è¡¨ç¤º" }, { filter: "general", text: "æ±ç”¨ãƒ™ãƒ«ãƒˆ" }, ...WEAPON_NAMES_FOR_CATEGORY.map(name => ({ filter: name, text: `${name}ç”¨` })), { filter: "pending", text: "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ" }, { filter: "storage", text: "å–ã‚Šæ•¢ãˆãšåç´" }].forEach(({ filter, text }) => { const button = document.createElement("button"); button.dataset.filter = filter; button.textContent = text; DOM.filterButtonGroup.appendChild(button); }); }
        
        function setupEventListeners() {
            DOM.saveButton.addEventListener('click', saveCurrentBelt);
            DOM.sortDivineButton.addEventListener('click', () => { AppState.currentSortDirection = 'divine'; updateDisplay(); });
            DOM.sortTrashButton.addEventListener('click', () => { AppState.currentSortDirection = 'trash'; updateDisplay(); });
            DOM.sealSettingsButton.addEventListener('click', () => { populateSealModal(); DOM.sealModal.style.display = 'flex'; });
            DOM.cancelSealSettingsButton.addEventListener('click', () => DOM.sealModal.style.display = 'none');
            DOM.saveSealSettingsButton.addEventListener('click', saveSealSettings);
            DOM.sealModal.addEventListener('click', e => { if (e.target === DOM.sealModal) DOM.sealModal.style.display = 'none'; });
            DOM.container.addEventListener('change', e => { if (e.target.tagName === 'SELECT') debouncedUpdateEffectSelectors(); });
            DOM.container.addEventListener('input', e => { if (e.target.classList.contains('effect-search')) debouncedUpdateEffectSelectors(); });
            DOM.filterButtonGroup.addEventListener('click', e => { if (e.target.tagName === 'BUTTON') { AppState.currentFilter = e.target.dataset.filter; updateDisplay(); } });
            DOM.savedBeltsList.addEventListener('click', e => {
                const target = e.target;
                const action = target.dataset.action;
                const beltItem = target.closest('.saved-belt-item');
                if (!beltItem) return;
                const effects = JSON.parse(beltItem.querySelector('.belt-selector').dataset.effectsJson);
                const actionHandlers = { load: loadBelt, lock: toggleLockState, delete: deleteBelt, memo: editMemo };
                if (action && actionHandlers[action] && !target.disabled) actionHandlers[action](effects);
            });
            DOM.savedBeltsList.addEventListener('change', e => {
                if(e.target.classList.contains('belt-selector')) {
                    const item = e.target.closest('.saved-belt-item');
                    item.classList.toggle('selected', e.target.checked);
                    updateBulkActionButtonsState();
                }
            });
        }
        function initialize() {
            migrateSavedBelts();
            generateSealableGroups();
            createEffectSelects();
            createFilterButtons();
            setupBulkActionButtons();
            rebuildOptionFragments();
            setupEventListeners();
            debouncedUpdateEffectSelectors();
            updateDisplay();
        }
        document.addEventListener('DOMContentLoaded', initialize);
    })();
  </script>
</body>
</html>
