<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>戦神のベルト管理ツール 再修正(ver1.8.3 UI改善版)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectとの間に少し余白 */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* 合計点数を非表示に */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; align-items: center; gap: 12px; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-item.selected { background-color: #e6f7ff; border-left-color: #007bff; }
    .belt-selector { flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }

    /* ★★★変更点：元のspanのスタイルは削除し、新しいクラスで管理します★★★ */
    .belt-memo { display: block; font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }

    /* ★★★変更点：王冠表示と文字ズレ防止のためのスタイルを追加★★★ */
    .effect-display-line {
        display: flex;
        align-items: baseline;
        margin-top: 4px;
    }
    .effect-display-line > span:last-child {
        font-size: 14px;
        color: #666;
    }
    .crown-container {
        width: 1.5em; /* 王冠一文字分の幅を確保 */
        flex-shrink: 0;
        text-align: center;
    }
    /* ★★★変更点ここまで★★★ */

    /* ★★★追加：理論値・準理論値ベルトの豪華なスタイル★★★ */
    .belt-theoretical {
        background: linear-gradient(145deg, #fffde7 10%, #fceabb 100%);
        border: 2px solid #fbc02d;
        box-shadow: 0 0 15px rgba(251, 192, 45, 0.6), 0 4px 12px rgba(0,0,0,0.15);
    }
    .belt-theoretical:hover {
        background: linear-gradient(145deg, #fffde7 10%, #fceabb 100%);
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 0 25px rgba(251, 192, 45, 0.8), 0 6px 16px rgba(0,0,0,0.2);
    }

    .belt-near-theoretical {
        background: linear-gradient(145deg, #f5f5f5 10%, #e0e0e0 100%);
        border: 2px solid #bdbdbd;
        box-shadow: 0 0 10px rgba(158, 158, 158, 0.5), 0 4px 12px rgba(0,0,0,0.1);
    }
    .belt-near-theoretical:hover {
        background: linear-gradient(145deg, #f5f5f5 10%, #e0e0e0 100%);
        transform: translateY(-4px) scale(1.01);
        box-shadow: 0 0 18px rgba(158, 158, 158, 0.7), 0 6px 16px rgba(0,0,0,0.15);
    }
    /* ★★★追加ここまで★★★ */

    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .action-button-group button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.7; }

    fieldset {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px 15px 15px 15px; /* 上、左右、下 */
      margin-bottom: 15px;
      background-color: #fafafa;
    }
    legend {
      font-weight: bold;
      font-size: 0.9em;
      padding: 0 8px;
      color: #333;
    }
    #bulkActionsContainer {
        border-bottom: none;
        padding-bottom: 0;
    }
    .action-button-group {
        margin-top: 5px; /* legendとの間に少し余白 */
    }

    #deleteAllUnlockedButton { background-color: #c82333; color: white; border-color: #c82333; }
    #deleteAllUnlockedButton:hover { background-color: #a71d2a; }

    /* カテゴリーごとの色を定義 */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; }

    /* 封印設定モーダル用のスタイル */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* トースト通知用のスタイル */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>戦神のベルト管理ツール</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">合計点数: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">封印効果の管理</button>
    <button id="saveButton">現在のベルトを保存</button>
  </div>

  <div id="savedBeltsSection">
    <h2>保存されたベルト<span id="savedBeltsCount"></span></h2>

    <fieldset>
      <legend>一括操作</legend>
      <div id="bulkActionsContainer" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>絞り込み</legend>
      <div id="filterButtonGroup" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>並び替え</legend>
      <div class="action-button-group" id="sortButtonGroup">
        <button id="sortDivine">神ベルト順</button>
        <button id="sortTrash">ゴミベルト順</button>
      </div>
    </fieldset>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>封印効果の管理</span><span id="sealedCount"></span></h2>
        <p>封印したい効果にチェックを入れてください。チェックした効果は、効果選択のプルダウンに表示されなくなります。選択後、保存するボタンを押してください。</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">キャンセル</button>
            <button id="saveSealSettingsButton">保存する</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // === 定数定義 ===
    const DATA_VERSION = '1.8.3';
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';
    const WEAPON_EFFECTS = {
        "右手に片手剣": 18, "両手剣": 17.9, "右手に短剣": 17.8, "右手にスティック": 17.7, "両手杖": 17.6,
        "ヤリ": 17.5, "オノ": 17.4, "棍": 17.3, "ツメ": 17.2, "ムチ": 17.1,
        "右手に扇": 17.0, "右手にハンマー": 16.9, "右手にブーメラン": 16.8, "弓": 16.7, "鎌": 16.6
    };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const WEAPON_NAMES_FOR_CATEGORY = [
        "片手剣", "両手剣", "短剣", "スティック", "両手杖", "ヤリ", "オノ", "棍", "ツメ", "ムチ", "扇", "ハンマー", "ブーメラン", "弓", "鎌"
    ];
    const ELEMENTS = ["炎", "氷", "風", "雷", "土", "闇", "光"];
    const MONSTER_TYPES = { "ドラゴン系": 16.5, "虫系": 16.4, "獣系": 16.3, "ゾンビ系": 16.2, "植物系": 16.1, "怪人系": 16.0, "悪魔系": 15.9, "エレ系": 15.8, "鳥系": 15.7, "物質系": 15.6, "スライム系": 15.5, "マシン系": 15.4, "水系": 15.3 };

    // === データ生成関数 ===
    function createAllEffectsData() {
        const categoryScores = { "汎用ベルト (カテゴリー用)": 40000, "保留中のベルト (カテゴリー用)": 6000, "取り敢えず収納 (カテゴリー用)": 4000 };
        let weaponScore = 38000;
        WEAPON_NAMES_FOR_CATEGORY.forEach(name => {
            categoryScores[`${name}用ベルト (カテゴリー用)`] = weaponScore;
            weaponScore -= 2000;
        });
        const effectScores = { "効果なし": -30, "こうげき力+15": 15, "こうげき力+20": 21.8, "こうげき力+25": 22, "こうげき魔力と回復魔力+30": 14.9, "こうげき魔力と回復魔力+40": 21.7, "こうげき魔力と回復魔力+50": 21.9, "会心率と呪文暴走率+1.0%": 14.8, "会心率と呪文暴走率+1.5%": 21.7, "会心率と呪文暴走率+2.0%": 21.8, "盾装備で開戦時○○系": 0.05 };
        Object.keys(WEAPON_EFFECTS).forEach(weapon => {
            const baseScore = WEAPON_EFFECTS[weapon];
            ELEMENTS.forEach(element => {
                [12, 13, 14, 15].forEach(val => {
                    effectScores[`${weapon}装備時 ${element}の攻撃ダメージ+${val}%`] = baseScore + (val - 12);
                });
            });
        });
        Object.keys(MONSTER_TYPES).forEach(type => {
            const baseScore = MONSTER_TYPES[type];
            for(let i = 0; i < 4; i++) {
                effectScores[`${type}にダメージ+${9+i}%`] = baseScore + i;
            }
        });
        return { ...categoryScores, ...effectScores };
    }
    const ALL_EFFECTS_DATA = createAllEffectsData();

    function createFilters() {
        const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } };
        let weaponScore = 38000;
        WEAPON_NAMES_FOR_CATEGORY.forEach(name => {
            const minScore = weaponScore - 2000;
            filters[name] = { min: minScore + 1849, max: weaponScore + 1848 };
            weaponScore -= 2000;
        });
        return filters;
    }
    const FILTERS = createFilters();

    // === グローバル変数 ===
    let sealableGroups = [];
    let groupKeyDataMap = new Map();
    let maxEffectInGroupMap = new Map(); // ★★★変更点：最大値効果を保持するMapを追加★★★
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    let isSorting = false;

    // === DOM要素のキャッシュ (DOMContentLoaded内で設定) ===
    let container, savedBeltsList, saveButton, sortDivineButton, sortTrashButton, savedBeltsCountElement, filterButtonGroup, sortButtonGroup, sealSettingsButton, sealModal, sealActionButtonsContainer, sealGroupsContainer, saveSealSettingsButton, cancelSealSettingsButton, sealedCountElement, toastContainer, bulkActionsContainer;
    let selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton;

    // === ユーティリティ関数 ===
    function showToast(message) { const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = message; toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
    function getSavedBelts() { try { const beltsJSON = localStorage.getItem(SAVED_BELTS_KEY); return beltsJSON ? JSON.parse(beltsJSON) : []; } catch (e) { console.error("Failed to parse saved belts:", e); return []; } }
    function saveBelts(belts) { localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(belts)); }
    function calculateTotalScore(effects) { return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0); }

    const getGroupKeyForEffect = (() => {
        const cache = new Map();
        const regex = /(\s*\+[\d\.]+%?)$/;
        return (effect) => {
            if (cache.has(effect)) return cache.get(effect);
            if (!effect || effect === '効果なし' || effect.includes('(カテゴリー用)')) {
                cache.set(effect, null);
                return null;
            }
            const key = effect.replace(regex, '').trim();
            const result = (key && key !== effect) ? key : effect;
            cache.set(effect, result);
            return result;
        };
    })();

    // === 封印機能関連 ===
    function getSealedGroups() { try { const sealedJSON = localStorage.getItem(SEALED_EFFECTS_KEY); return sealedJSON ? JSON.parse(sealedJSON) : []; } catch (e) { console.error("Failed to parse sealed effects:", e); return []; } }
    function isEffectSealed(effect, sealedGroups) { if (!sealedGroups || sealedGroups.length === 0) return false; const groupKey = getGroupKeyForEffect(effect); return groupKey ? sealedGroups.some(g => g.startsWith(groupKey)) : false; }
    function updateSealedCount() { if (!sealableGroups || sealableGroups.length === 0) return; const checkedCount = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length; const totalCount = sealableGroups.length; sealedCountElement.textContent = `(${checkedCount} / ${totalCount} 件 封印中)`; }
    function populateSealModal() { sealActionButtonsContainer.innerHTML = ''; const selectAllButton = document.createElement('button'); selectAllButton.textContent = 'すべて選択'; selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); }); const deselectAllButton = document.createElement('button'); deselectAllButton.textContent = 'すべて解除'; deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); }); sealActionButtonsContainer.appendChild(selectAllButton); sealActionButtonsContainer.appendChild(deselectAllButton); sealGroupsContainer.innerHTML = ''; const sealedGroups = getSealedGroups(); sealableGroups.forEach(group => { const div = document.createElement('div'); div.className = 'seal-group'; const label = document.createElement('label'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group); checkbox.addEventListener('change', updateSealedCount); label.appendChild(checkbox); label.appendChild(document.createTextNode(group)); div.appendChild(label); sealGroupsContainer.appendChild(div); }); updateSealedCount(); }
    function saveSealSettings() { const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked'); const sealedGroups = Array.from(checkboxes).map(cb => cb.value); localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups)); sealModal.style.display = 'none'; updateAllSelectOptions(); showToast("封印設定を保存しました。"); }

    // === ベルトデータ管理 (保存/削除/更新) ===
    function migrateSavedBelts() {
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion === DATA_VERSION) return;
        let savedBelts = getSavedBelts();
        const migratedBelts = savedBelts.map(belt => {
            let currentBelt = belt;
            if (Array.isArray(currentBelt)) currentBelt = { effects: currentBelt, locked: false, memo: '' };
            if (typeof currentBelt !== 'object' || currentBelt === null || !Array.isArray(currentBelt.effects)) return null;
            const newEffects = currentBelt.effects.map(effect => {
                let newEffect = effect;
                newEffect = newEffect.replace(/^右手に(片手剣|短剣|スティック|扇|ハンマー|ブーメラン)用ベルト/, '$1用ベルト');
                newEffect = newEffect.replace(/^(片手剣|短剣|スティック|扇|ハンマー|ブーメラン)装備時/, '右手に$1装備時');
                return newEffect;
            });
            return { effects: newEffects, locked: !!currentBelt.locked, memo: currentBelt.memo || '' };
        }).filter(Boolean);
        saveBelts(migratedBelts);
        localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
        console.log(`ベルトデータをver ${DATA_VERSION} に更新しました。`);
        showToast("データ構造を最新版に更新しました。");
    }

    function saveCurrentBelt() {
        const currentEffects = Array.from(container.querySelectorAll('select')).map(s => s.value);
        if (currentEffects.slice(1).every(e => e === '効果なし')) {
            showToast("有効な効果がありません。ベルトを保存できません。");
            return;
        }
        const savedBelts = getSavedBelts();
        const newBeltData = { effects: currentEffects, locked: false, memo: '' };
        if (savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects))) {
            showToast("この効果の組み合わせは既に保存されています。");
            return;
        }
        const newBeltEffectGroups = new Set(currentEffects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
        if (newBeltEffectGroups.size > 0) {
            let mostSimilar = { count: 0, groups: [] };
            for (const savedBelt of savedBelts) {
                const existingBeltEffectGroups = new Set(savedBelt.effects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
                const intersection = new Set([...newBeltEffectGroups].filter(group => existingBeltEffectGroups.has(group)));
                if (intersection.size > mostSimilar.count) {
                    mostSimilar = { count: intersection.size, groups: [...intersection] };
                }
            }
            if (mostSimilar.count >= 2) {
                const message = `効果が${mostSimilar.count}つ重複するベルトを所有しています。\n\n効果内容:\n${mostSimilar.groups.map(key => groupKeyDataMap.get(key)?.group || key).join('\n')}\n\nそれでもこのベルトを保存しますか？`;
                if (!confirm(message)) {
                    showToast("保存をキャンセルしました。");
                    return;
                }
            }
        }
        savedBelts.push(newBeltData);
        saveBelts(savedBelts);
        showToast("ベルトを保存しました！");
        updateDisplay();
    }

    function deleteBelt(effectsToDelete) { if (!confirm("このベルトを本当に削除しますか？")) return; let savedBelts = getSavedBelts(); const effectsToDeleteStr = JSON.stringify(effectsToDelete); const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr); saveBelts(updatedBelts); showToast("ベルトを削除しました。"); updateDisplay(); }
    function editMemo(effectsToEdit) { let savedBelts = getSavedBelts(); const effectsToEditStr = JSON.stringify(effectsToEdit); const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr); if (beltToEdit) { const newMemo = prompt("ベルトのメモを入力してください：", beltToEdit.memo || ""); if (newMemo !== null) { beltToEdit.memo = newMemo.trim(); saveBelts(savedBelts); showToast("メモを更新しました。"); updateDisplay(); } } }
    function toggleLockState(effectsToToggle) { let savedBelts = getSavedBelts(); const effectsToToggleStr = JSON.stringify(effectsToToggle); const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr); if (beltToToggle) { beltToToggle.locked = !beltToToggle.locked; saveBelts(savedBelts); showToast(beltToToggle.locked ? "ベルトをロックしました。" : "ベルトのロックを解除しました。"); updateDisplay(); } }

    // === 表示関連 ===
    // ★★★変更点：理論値・準理論値のスタイルを適用するようにロジックを修正★★★
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(表示: ${beltsToRender.length}個 / 合計: ${totalSavedCount}個)`;
        if (beltsToRender.length === 0) {
            const noBeltMessage = document.createElement('p');
            noBeltMessage.textContent = '表示対象のベルトがありません。';
            noBeltMessage.style.textAlign = 'center';
            noBeltMessage.style.color = '#888';
            savedBeltsList.appendChild(noBeltMessage);
            updateBulkActionButtonsState();
            return;
        }
        const fragment = document.createDocumentFragment();
        const categoryClassMap = new Map([["汎用ベルト (カテゴリー用)", "category-general"], ["保留中のベルト (カテゴリー用)", "category-pending"], ["取り敢えず収納 (カテゴリー用)", "category-storage"]]);
        WEAPON_NAMES_FOR_CATEGORY.forEach((name, index) => { categoryClassMap.set(`${name}用ベルト (カテゴリー用)`, `category-weapon-${index}`); });
        
        beltsToRender.forEach(({ effects, locked, memo }) => {
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            beltItem.classList.add(categoryClassMap.get(effects[0]) || 'category-default');
            beltItem.dataset.effectsJson = JSON.stringify(effects);

            // ★★★追加：理論値・準理論値の判定とクラス付与★★★
            let crownCount = 0;
            const validEffects = effects.slice(1).filter(e => e !== '効果なし');
            const validEffectCount = validEffects.length;

            validEffects.forEach(effect => {
                const groupKey = getGroupKeyForEffect(effect);
                if (groupKey && maxEffectInGroupMap.get(groupKey) === effect) {
                    crownCount++;
                }
            });

            if (validEffectCount > 0 && crownCount === validEffectCount) {
                beltItem.classList.add('belt-theoretical');
            } else if (crownCount === 4) {
                beltItem.classList.add('belt-near-theoretical');
            }
            // ★★★追加ここまで★★★

            const effectsHtml = effects.filter(e => e !== '効果なし').map(effect => {
                const groupKey = getGroupKeyForEffect(effect);
                const isMax = groupKey && maxEffectInGroupMap.get(groupKey) === effect;
                const crownHtml = isMax ? '👑' : '';
                return `
                    <div class="effect-display-line">
                        <span class="crown-container">${crownHtml}</span>
                        <span>${effect}</span>
                    </div>`;
            }).join('');

            beltItem.innerHTML = `
                <input type="checkbox" class="belt-selector">
                <div class="saved-belt-info">
                    ${effectsHtml}
                    ${memo ? `<span class="belt-memo">📝 ${memo}</span>` : ''}
                </div>
                <div class="saved-belt-actions">
                    <div class="saved-belt-actions-upper">
                        <button class="saved-belt-lock">${locked ? '解除' : 'ロック'}</button>
                        <button class="saved-belt-delete" ${locked ? 'disabled' : ''}>削除</button>
                    </div>
                    <button class="saved-belt-memo-edit">メモ編集</button>
                </div>
            `;
            fragment.appendChild(beltItem);
        });
        savedBeltsList.appendChild(fragment);
        updateBulkActionButtonsState();
    }


    // === プルダウン選択肢の生成・更新 ===
    function rebuildOptionFragments() { fullOptionsFragment = document.createDocumentFragment(); categoryOptionsFragment = document.createDocumentFragment(); effectOptionsFragment = document.createDocumentFragment(); const sealedGroups = getSealedGroups(); for (const effectName in ALL_EFFECTS_DATA) { if (isEffectSealed(effectName, sealedGroups)) continue; const option = document.createElement("option"); option.value = effectName; option.textContent = effectName; fullOptionsFragment.appendChild(option.cloneNode(true)); if (effectName.includes("(カテゴリー用)") || effectName === "効果なし") { categoryOptionsFragment.appendChild(option.cloneNode(true)); } if (!effectName.includes("(カテゴリー用)") || effectName === "効果なし") { effectOptionsFragment.appendChild(option.cloneNode(true)); } } }
    function updateAllSelectOptions() { rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const currentValue = select.value; const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.innerHTML = ""; select.appendChild(sourceFragment.cloneNode(true)); if (Array.from(select.options).some(o => o.value === currentValue)) { select.value = currentValue; } else { select.value = "効果なし"; } }); updateAndSort(); }

    // === 並び替え・フィルタリングのメイン関数 ===
    function updateAndSort() {
        if (isSorting) return;
        isSorting = true;
        const allSelects = Array.from(container.querySelectorAll('select'));
        const searchInputs = Array.from(container.querySelectorAll('.effect-search'));
        const originalValues = allSelects.map(s => s.value);
        const sortedEffects = [...originalValues.slice(1)].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));
        const finalValues = [originalValues[0], ...sortedEffects];
        
        allSelects.forEach((select, currentIndex) => {
            const finalValueForThisSelect = finalValues[currentIndex];
            const searchTerm = searchInputs[currentIndex] ? searchInputs[currentIndex].value.toLowerCase() : '';
            const otherUsedGroupKeys = new Set(finalValues.map((v, i) => (currentIndex !== i ? getGroupKeyForEffect(v) : null)).filter(Boolean));
            
            const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();
            
            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === finalValueForThisSelect;
                const matchesSearch = !searchTerm || optionNode.textContent.toLowerCase().includes(searchTerm);
                if (isSelectableByGroup && matchesSearch) {
                    newOptionsFragment.appendChild(optionNode.cloneNode(true));
                }
            });
            
            select.innerHTML = '';
            select.appendChild(newOptionsFragment);
            
            if (!Array.from(select.options).some(opt => opt.value === finalValueForThisSelect) && finalValueForThisSelect !== '効果なし') {
                const restoredOption = document.createElement('option');
                restoredOption.value = finalValueForThisSelect;
                restoredOption.textContent = finalValueForThisSelect;
                select.insertBefore(restoredOption, select.firstChild);
            }
            select.value = finalValueForThisSelect;
        });
        
        document.getElementById("totalScore").textContent = `合計点数: ${calculateTotalScore(finalValues).toFixed(1)}`;
        isSorting = false;
    }

    // === 表示更新・フィルタリング・ソート ===
    function updateDisplay() { let allBelts = getSavedBelts(); let beltsWithScore = allBelts.map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) })); const filterRange = FILTERS[currentFilter]; let filteredBelts = beltsWithScore.filter(belt => belt.score >= filterRange.min && belt.score <= filterRange.max); filteredBelts.sort((a, b) => currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score); renderSavedBelts(filteredBelts); updateActiveButtons(); }
    function updateActiveButtons() { filterButtonGroup.querySelectorAll("button").forEach(btn => btn.classList.toggle("active", btn.dataset.filter === currentFilter)); sortButtonGroup.querySelectorAll("button").forEach(btn => btn.classList.toggle("active", (btn.id === "sortDivine" && currentSortDirection === "divine") || (btn.id === "sortTrash" && currentSortDirection === "trash"))); }
    function loadBelt(effects) { const selects = container.querySelectorAll('select'); const searchInputs = container.querySelectorAll('.effect-search'); searchInputs.forEach(input => { input.value = ""; }); selects.forEach((select, index) => { select.value = effects[index] || '効果なし'; }); updateAndSort(); window.scrollTo(0, 0); }

    // === 一括操作関連の関数 ===
    function setupBulkActionButtons() {
        bulkActionsContainer.innerHTML = '';
        selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'すべて選択';
        lockSelectedButton = document.createElement('button');
        lockSelectedButton.textContent = '選択をロック';
        unlockSelectedButton = document.createElement('button');
        unlockSelectedButton.textContent = '選択をロック解除';
        deleteSelectedButton = document.createElement('button');
        deleteSelectedButton.textContent = '選択を削除（ロックを除く）';
        lockAllButton = document.createElement('button');
        lockAllButton.textContent = 'すべてロック';
        unlockAllButton = document.createElement('button');
        unlockAllButton.textContent = 'すべてロック解除';
        deleteAllUnlockedButton = document.createElement('button');
        deleteAllUnlockedButton.id = 'deleteAllUnlockedButton';
        deleteAllUnlockedButton.textContent = '全削除(ロック除く)';
        bulkActionsContainer.append(selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton);
    }
    function updateBulkActionButtonsState() { const selectedCount = savedBeltsList.querySelectorAll('.belt-selector:checked').length; const totalCount = savedBeltsList.querySelectorAll('.belt-selector').length; lockSelectedButton.disabled = selectedCount === 0; unlockSelectedButton.disabled = selectedCount === 0; deleteSelectedButton.disabled = selectedCount === 0; if (totalCount === 0) { selectAllButton.textContent = 'すべて選択'; selectAllButton.disabled = true; } else { selectAllButton.disabled = false; selectAllButton.textContent = selectedCount === 0 ? 'すべて選択' : selectedCount === totalCount ? 'すべて解除' : `選択中 ${selectedCount}`; } }
    function toggleSelectAll() { const checkboxes = savedBeltsList.querySelectorAll('.belt-selector'); const shouldSelectAll = Array.from(checkboxes).some(cb => !cb.checked); checkboxes.forEach(cb => { if (cb.checked !== shouldSelectAll) { cb.checked = shouldSelectAll; cb.closest('.saved-belt-item').classList.toggle('selected', shouldSelectAll); } }); updateBulkActionButtonsState(); }
    function getSelectedEffectsJson() { return Array.from(savedBeltsList.querySelectorAll('.belt-selector:checked')).map(cb => cb.closest('.saved-belt-item').dataset.effectsJson); }
    function operateOnSelectedBelts(operation) {
        const selectedEffectsJson = getSelectedEffectsJson();
        if (selectedEffectsJson.length === 0) { showToast("ベルトが選択されていません。"); return; }
        operation(selectedEffectsJson);
    }
    function lockSelectedBelts() { operateOnSelectedBelts(selected => { if (confirm(`選択した ${selected.length} 個のベルトをロックしますか？`)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (selected.includes(JSON.stringify(b.effects)) && !b.locked) { b.locked = true; count++; } }); if (count > 0) { saveBelts(belts); showToast(`${count} 個のベルトをロックしました。`); updateDisplay(); } else { showToast(`ロック対象のベルトはありませんでした。`); } } }); }
    function unlockSelectedBelts() { operateOnSelectedBelts(selected => { if (confirm(`選択した ${selected.length} 個のベルトのロックを解除しますか？`)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (selected.includes(JSON.stringify(b.effects)) && b.locked) { b.locked = false; count++; } }); if (count > 0) { saveBelts(belts); showToast(`${count} 個のベルトのロックを解除しました。`); updateDisplay(); } else { showToast(`ロック解除対象のベルトはありませんでした。`); } } }); }
    function deleteSelectedBelts() { operateOnSelectedBelts(selected => { const allBelts = getSavedBelts(); const toDelete = allBelts.filter(b => selected.includes(JSON.stringify(b.effects)) && !b.locked); const lockedCount = selected.length - toDelete.length; if (toDelete.length === 0) { showToast('削除対象のベルトがありません。(ロックされているベルトは削除できません)'); return; } let confirmMsg = `選択した ${toDelete.length} 個のベルトを削除しますか？`; if (lockedCount > 0) confirmMsg += `\n\n(注意: ロックされている ${lockedCount} 個のベルトは削除されません)`; if (confirm(confirmMsg)) { const toDeleteSet = new Set(toDelete.map(b => JSON.stringify(b.effects))); const updatedBelts = allBelts.filter(b => !toDeleteSet.has(JSON.stringify(b.effects))); saveBelts(updatedBelts); showToast(`${toDelete.length} 個のベルトを削除しました。`); updateDisplay(); } }); }
    function operateOnAllBelts(operation) { if (confirm(operation.confirmMessage)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (operation.predicate(b)) { operation.action(b); count++; } }); if (count > 0) { saveBelts(belts); showToast(operation.successMessage(count)); updateDisplay(); } else { showToast(operation.noChangeMessage); } } }
    function lockAllBelts() { operateOnAllBelts({ confirmMessage: '保存されているすべてのベルトをロックしますか？', predicate: b => !b.locked, action: b => b.locked = true, successMessage: count => `${count} 個のベルトをロックしました。`, noChangeMessage: 'すべてのベルトは既にロックされています。' }); }
    function unlockAllBelts() { operateOnAllBelts({ confirmMessage: '保存されているすべてのベルトのロックを解除しますか？', predicate: b => b.locked, action: b => b.locked = false, successMessage: count => `${count} 個のベルトのロックを解除しました。`, noChangeMessage: 'ロックされているベルトはありませんでした。' }); }
    function deleteAllUnlockedBelts() { const savedBelts = getSavedBelts(); const unlockedCount = savedBelts.filter(b => !b.locked).length; if (unlockedCount === 0) { showToast('削除対象のベルト(ロックされていないベルト)がありません。'); return; } if (confirm(`【危険】ロックされていない ${unlockedCount} 個のベルトをすべて削除しますか？\nこの操作は元に戻すことができません！`)) { const confirmationText = 'delete'; const userInput = prompt(`本当に削除する場合は、「${confirmationText}」と入力してください。`); if (userInput === confirmationText) { const updatedBelts = savedBelts.filter(b => b.locked); saveBelts(updatedBelts); showToast(`ロックされていない ${unlockedCount} 個のベルトをすべて削除しました。`); updateDisplay(); } else { showToast('入力が一致しなかったため、削除をキャンセルしました。'); } } }

    // === 初期化処理 ===
    function generateSealableGroups() {
        groupKeyDataMap.clear();
        const addGroup = (name, score) => { const key = name.replace(/\+\?%?/, '').trim(); if (!groupKeyDataMap.has(key)) groupKeyDataMap.set(key, { group: name, score: score }); };
        addGroup("こうげき力+?", ALL_EFFECTS_DATA["こうげき力+25"]);
        addGroup("こうげき魔力と回復魔力+?", ALL_EFFECTS_DATA["こうげき魔力と回復魔力+50"]);
        addGroup("会心率と呪文暴走率+?%", ALL_EFFECTS_DATA["会心率と呪文暴走率+2.0%"]);
        WEAPON_NAMES.forEach(weapon => { ELEMENTS.forEach(element => { addGroup(`${weapon}装備時 ${element}の攻撃ダメージ+?%`, WEAPON_EFFECTS[weapon] + 3); }); });
        Object.keys(MONSTER_TYPES).forEach(type => addGroup(`${type}にダメージ+?%`, MONSTER_TYPES[type] + 3));
        addGroup("盾装備で開戦時○○系", 0.05);
        sealableGroups = Array.from(groupKeyDataMap.values()).sort((a, b) => b.score - a.score || a.group.localeCompare(b.group, 'ja')).map(g => g.group);
    }
    // ★★★変更点：最大値効果マップを生成する関数を追加★★★
    function generateMaxEffectMap() {
        maxEffectInGroupMap.clear();
        for (const effectName in ALL_EFFECTS_DATA) {
            const groupKey = getGroupKeyForEffect(effectName);
            if (!groupKey) continue;
            const currentScore = ALL_EFFECTS_DATA[effectName];
            const existingMaxEffectName = maxEffectInGroupMap.get(groupKey);
            if (!existingMaxEffectName || currentScore > ALL_EFFECTS_DATA[existingMaxEffectName]) {
                maxEffectInGroupMap.set(groupKey, effectName);
            }
        }
    }
    function createEffectSelects() { const labels = ["カテゴリー", "効果 1", "効果 2", "効果 3", "効果 4", "効果 5"]; labels.forEach((labelText, index) => { const block = document.createElement("div"); block.className = "effect-block"; block.innerHTML = `<label>${labelText}</label><input type="text" class="effect-search" placeholder="効果を検索して絞り込み..."><select data-type="${index === 0 ? "category" : "effect"}"></select>`; container.appendChild(block); }); rebuildOptionFragments(); document.querySelectorAll("#effectsContainer select").forEach(select => { select.appendChild((select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment).cloneNode(true)); }); container.addEventListener('change', e => { if (e.target.tagName === 'SELECT') updateAndSort(); }); container.addEventListener('input', e => { if (e.target.classList.contains('effect-search')) updateAndSort(); }); }
    function createFilterButtons() { filterButtonGroup.innerHTML = ""; [{ filter: "all", text: "すべて表示" }, { filter: "general", text: "汎用ベルト" }, ...WEAPON_NAMES_FOR_CATEGORY.map(name => ({ filter: name, text: `${name}用` })), { filter: "pending", text: "保留中のベルト" }, { filter: "storage", text: "取り敢えず収納" }].forEach(({ filter, text }) => { const button = document.createElement("button"); button.dataset.filter = filter; button.textContent = text; filterButtonGroup.appendChild(button); }); }
    
    function initializeEventListeners() {
        // --- メイン操作ボタン ---
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });

        // --- フィルターボタン (イベントデリゲーション) ---
        filterButtonGroup.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { currentFilter = e.target.dataset.filter; updateDisplay(); } });

        // --- 封印モーダル ---
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', e => { if (e.target === sealModal) sealModal.style.display = 'none'; });

        // --- 保存済みベルトリスト (イベントデリゲーション) ---
        savedBeltsList.addEventListener('click', e => {
            const beltItem = e.target.closest('.saved-belt-item');
            if (!beltItem) return;
            const effects = JSON.parse(beltItem.dataset.effectsJson);
            if (e.target.matches('.saved-belt-lock')) toggleLockState(effects);
            else if (e.target.matches('.saved-belt-delete:not(:disabled)')) deleteBelt(effects);
            else if (e.target.matches('.saved-belt-memo-edit')) editMemo(effects);
            else if (e.target.closest('.saved-belt-info')) loadBelt(effects);
        });
        savedBeltsList.addEventListener('change', e => {
            if (e.target.matches('.belt-selector')) {
                e.target.closest('.saved-belt-item').classList.toggle('selected', e.target.checked);
                updateBulkActionButtonsState();
            }
        });

        // --- 一括操作ボタン ---
        selectAllButton.addEventListener('click', toggleSelectAll);
        lockSelectedButton.addEventListener('click', lockSelectedBelts);
        unlockSelectedButton.addEventListener('click', unlockSelectedBelts);
        deleteSelectedButton.addEventListener('click', deleteSelectedBelts);
        lockAllButton.addEventListener('click', lockAllBelts);
        unlockAllButton.addEventListener('click', unlockAllBelts);
        deleteAllUnlockedButton.addEventListener('click', deleteAllUnlockedBelts);
    }

    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM要素のキャッシュ ---
        container = document.getElementById('effectsContainer');
        savedBeltsList = document.getElementById('savedBeltsList');
        saveButton = document.getElementById('saveButton');
        sortDivineButton = document.getElementById('sortDivine');
        sortTrashButton = document.getElementById('sortTrash');
        savedBeltsCountElement = document.getElementById('savedBeltsCount');
        filterButtonGroup = document.getElementById('filterButtonGroup');
        sortButtonGroup = document.getElementById('sortButtonGroup');
        sealSettingsButton = document.getElementById('sealSettingsButton');
        sealModal = document.getElementById('sealModal');
        sealActionButtonsContainer = document.getElementById('sealActionButtons');
        sealGroupsContainer = document.getElementById('sealGroupsContainer');
        saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
        cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
        sealedCountElement = document.getElementById('sealedCount');
        toastContainer = document.getElementById('toast-container');
        bulkActionsContainer = document.getElementById('bulkActionsContainer');
        
        // --- 初期化処理 ---
        migrateSavedBelts();
        generateSealableGroups();
        generateMaxEffectMap(); // ★★★変更点：最大値マップ生成関数を呼び出し★★★
        createEffectSelects();
        createFilterButtons();
        setupBulkActionButtons();
        initializeEventListeners();
        
        // --- 初期表示 ---
        updateAndSort();
        updateDisplay();
    });
  </script>
</body>
</html>
