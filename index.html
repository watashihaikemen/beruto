<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>戦神のベルト管理ツール 再修正(ver1.8.1)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectとの間に少し余白 */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* 合計点数を非表示に */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; align-items: center; gap: 12px; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-item.selected { background-color: #e6f7ff; border-left-color: #007bff; }
    .belt-selector { flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .action-button-group button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.7; }
    #bulkActionsContainer { border-bottom: 1px solid #ddd; padding-bottom: 15px; }
    #deleteAllUnlockedButton { background-color: #c82333; color: white; border-color: #c82333; }
    #deleteAllUnlockedButton:hover { background-color: #a71d2a; }

    /* カテゴリーごとの色を定義 */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; }

    /* 封印設定モーダル用のスタイル */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* トースト通知用のスタイル */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>戦神のベルト管理ツール</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">合計点数: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">封印効果の管理</button>
    <button id="saveButton">現在のベルトを保存</button>
  </div>

  <div id="savedBeltsSection">
    <h2>保存されたベルト<span id="savedBeltsCount"></span></h2>
    <div id="bulkActionsContainer" class="action-button-group"></div>
    <div id="filterButtonGroup" class="action-button-group"></div>
    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">神ベルト順</button>
      <button id="sortTrash">ゴミベルト順</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>封印効果の管理</span><span id="sealedCount"></span></h2>
        <p>封印したい効果にチェックを入れてください。チェックした効果は、効果選択のプルダウンに表示されなくなります。選択後、保存するボタンを押してください。</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">キャンセル</button>
            <button id="saveSealSettingsButton">保存する</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // ★★★変更点：バージョンを1.8.1に更新（ロック解除機能追加）★★★
    const DATA_VERSION = '1.8.1'; 
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';

    const WEAPON_EFFECTS = { "片手剣": 18, "両手剣": 17.9, "短剣": 17.8, "スティック": 17.7, "両手杖": 17.6, "ヤリ": 17.5, "オノ": 17.4, "棍": 17.3, "ツメ": 17.2, "ムチ": 17.1, "扇": 17.0, "ハンマー": 16.9, "ブーメラン": 16.8, "弓": 16.7, "鎌": 16.6 };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const ELEMENTS = ["炎", "氷", "風", "雷", "土", "闇", "光"];
    const MONSTER_TYPES = { "ドラゴン系": 16.5, "虫系": 16.4, "獣系": 16.3, "ゾンビ系": 16.2, "植物系": 16.1, "怪人系": 16.0, "悪魔系": 15.9, "エレ系": 15.8, "鳥系": 15.7, "物質系": 15.6, "スライム系": 15.5, "マシン系": 15.4, "水系": 15.3 };
    
    function createAllEffectsData() { /* 省略 (変更なし) */ const categoryScores = { "汎用ベルト (カテゴリー用)": 40000, "保留中のベルト (カテゴリー用)": 6000, "取り敢えず収納 (カテゴリー用)": 4000 }; let weaponScore = 38000; WEAPON_NAMES.forEach(name => { categoryScores[`${name}用ベルト (カテゴリー用)`] = weaponScore; weaponScore -= 2000; }); const effectScores = { "効果なし": -30, "こうげき力+15": 15, "こうげき力+20": 21.8, "こうげき力+25": 22, "こうげき魔力と回復魔力+30": 14.9, "こうげき魔力と回復魔力+40": 21.7, "こうげき魔力と回復魔力+50": 21.9, "会心率と呪文暴走率+1.0%": 14.8, "会心率と呪文暴走率+1.5%": 21.7, "会心率と呪文暴走率+2.0%": 21.8, "盾装備で開戦時○○系": 0.05 }; Object.keys(WEAPON_EFFECTS).forEach(weapon => { const baseScore = WEAPON_EFFECTS[weapon]; ELEMENTS.forEach(element => { [12, 13, 14, 15].forEach(val => { effectScores[`${weapon}装備時 ${element}の攻撃ダメージ+${val}%`] = baseScore + (val - 12); }); }); }); Object.keys(MONSTER_TYPES).forEach(type => { const baseScore = MONSTER_TYPES[type]; for(let i = 0; i < 4; i++) { effectScores[`${type}にダメージ+${9+i}%`] = baseScore + i; } }); return { ...categoryScores, ...effectScores }; }
    const ALL_EFFECTS_DATA = createAllEffectsData();
    
    function createFilters() { /* 省略 (変更なし) */ const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } }; let weaponScore = 38000; WEAPON_NAMES.forEach(name => { const minScore = weaponScore - 2000; filters[name] = { min: minScore + 1849, max: weaponScore + 1848 }; weaponScore -= 2000; }); return filters; }
    const FILTERS = createFilters();

    // === グローバル変数 ===
    let sealableGroups = [];
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    let isSorting = false;

    // === DOM要素の取得 ===
    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    const sealSettingsButton = document.getElementById('sealSettingsButton');
    const sealModal = document.getElementById('sealModal');
    const sealActionButtonsContainer = document.getElementById('sealActionButtons');
    const sealGroupsContainer = document.getElementById('sealGroupsContainer');
    const saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
    const cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
    const sealedCountElement = document.getElementById('sealedCount');
    const toastContainer = document.getElementById('toast-container');
    const bulkActionsContainer = document.getElementById('bulkActionsContainer');
    let selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton;

    // === ユーティリティ関数 ===
    function showToast(message) { /* 省略 (変更なし) */ const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = message; toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
    function getSavedBelts() { /* 省略 (変更なし) */ const beltsJSON = localStorage.getItem(SAVED_BELTS_KEY); return beltsJSON ? JSON.parse(beltsJSON) : []; }
    function calculateTotalScore(effects) { /* 省略 (変更なし) */ return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0); }
    function getGroupKeyForEffect(effect) { /* 省略 (変更なし) */ if (!effect || effect === '効果なし' || effect.includes('(カテゴリー用)')) { return null; } const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim(); if (key && key !== effect) { return key; } return effect; }

    // === 封印機能関連 ===
    function getSealedGroups() { /* 省略 (変更なし) */ return localStorage.getItem(SEALED_EFFECTS_KEY) ? JSON.parse(localStorage.getItem(SEALED_EFFECTS_KEY)) : []; }
    function isEffectSealed(effect, sealedGroups) { /* 省略 (変更なし) */ if (!sealedGroups || sealedGroups.length === 0) return false; const groupKey = getGroupKeyForEffect(effect); if (groupKey) { const genericGroupKey = groupKey.replace(/装備時 |の攻撃ダメージ/, "装備時 ○○の攻撃ダメージ").replace(/にダメージ/, "にダメージ") + "+?%"; const simpleKey = groupKey + "+?"; if (sealedGroups.some(g => g.startsWith(groupKey))) return true; } return sealedGroups.some(groupPrefix => effect.startsWith(groupPrefix.replace(/\+\?%?/, '').replace("○○系", ""))); }
    function updateSealedCount() { /* 省略 (変更なし) */ if (!sealableGroups || sealableGroups.length === 0) return; const checkedCount = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length; const totalCount = sealableGroups.length; sealedCountElement.textContent = `(${checkedCount} / ${totalCount} 件 封印中)`; }
    function populateSealModal() { /* 省略 (変更なし) */ sealActionButtonsContainer.innerHTML = ''; const selectAllButton = document.createElement('button'); selectAllButton.textContent = 'すべて選択'; selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); }); const deselectAllButton = document.createElement('button'); deselectAllButton.textContent = 'すべて解除'; deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); }); sealActionButtonsContainer.appendChild(selectAllButton); sealActionButtonsContainer.appendChild(deselectAllButton); sealGroupsContainer.innerHTML = ''; const sealedGroups = getSealedGroups(); sealableGroups.forEach(group => { const div = document.createElement('div'); div.className = 'seal-group'; const label = document.createElement('label'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group); checkbox.addEventListener('change', updateSealedCount); label.appendChild(checkbox); label.appendChild(document.createTextNode(group)); div.appendChild(label); sealGroupsContainer.appendChild(div); }); updateSealedCount(); }
    function saveSealSettings() { /* 省略 (変更なし) */ const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked'); const sealedGroups = Array.from(checkboxes).map(cb => cb.value); localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups)); sealModal.style.display = 'none'; updateAllSelectOptions(); showToast("封印設定を保存しました。"); }

    // === ベルトデータ管理 (保存/削除/更新) ===
    function migrateSavedBelts() { /* 省略 (変更なし) */ let savedBelts = getSavedBelts(); const storedVersion = localStorage.getItem(DATA_VERSION_KEY); if (storedVersion === DATA_VERSION || savedBelts.length === 0) { localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION); return; } const migratedBelts = savedBelts.map(belt => { if (Array.isArray(belt)) { return { effects: belt, locked: false, memo: '' }; } if (typeof belt !== 'object' || belt === null) return null; if (!Array.isArray(belt.effects)) return null; return { effects: belt.effects, locked: belt.locked === true, memo: belt.memo || '' }; }).filter(Boolean); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(migratedBelts)); localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION); console.log("ベルトデータをver " + DATA_VERSION + " に更新しました。"); }
    function saveCurrentBelt() { /* 省略 (変更なし) */ const selects = container.querySelectorAll('select'); const currentEffects = Array.from(selects).map(s => s.value); const validEffectsCount = currentEffects.slice(1).filter(e => e !== '効果なし').length; if (validEffectsCount < 1) { showToast("有効な効果がありません。ベルトを保存できません。"); return; } const savedBelts = getSavedBelts(); const newBeltData = { effects: currentEffects, locked: false, memo: '' }; const isDuplicate = savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects)); if (isDuplicate) { showToast("この効果の組み合わせは既に保存されています。"); return; } savedBelts.push(newBeltData); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast("ベルトを保存しました！"); updateDisplay(); }
    function deleteBelt(effectsToDelete) { /* 省略 (変更なし) */ if (!confirm("このベルトを本当に削除しますか？")) return; let savedBelts = getSavedBelts(); const effectsToDeleteStr = JSON.stringify(effectsToDelete); const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts)); showToast("ベルトを削除しました。"); updateDisplay(); }
    function editMemo(effectsToEdit) { /* 省略 (変更なし) */ let savedBelts = getSavedBelts(); const effectsToEditStr = JSON.stringify(effectsToEdit); const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr); if (beltToEdit) { const newMemo = prompt("ベルトのメモを入力してください：", beltToEdit.memo || ""); if (newMemo !== null) { beltToEdit.memo = newMemo.trim(); localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast("メモを更新しました。"); updateDisplay(); } } }
    function toggleLockState(effectsToToggle) { /* 省略 (変更なし) */ let savedBelts = getSavedBelts(); const effectsToToggleStr = JSON.stringify(effectsToToggle); const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr); if (beltToToggle) { beltToToggle.locked = !beltToToggle.locked; localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts)); showToast(beltToToggle.locked ? "ベルトをロックしました。" : "ベルトのロックを解除しました。"); updateDisplay(); } }

    // === 表示関連 ===
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(表示: ${beltsToRender.length}個 / 合計: ${totalSavedCount}個)`;
        const categoryClassMap = { "汎用ベルト (カテゴリー用)": "category-general", "保留中のベルト (カテゴリー用)": "category-pending", "取り敢えず収納 (カテゴリー用)": "category-storage" };
        WEAPON_NAMES.forEach((name, index) => { categoryClassMap[`${name}用ベルト (カテゴリー用)`] = `category-weapon-${index}`; });
        if (beltsToRender.length === 0) {
            const noBeltMessage = document.createElement('p');
            noBeltMessage.textContent = '表示対象のベルトがありません。';
            noBeltMessage.style.textAlign = 'center'; noBeltMessage.style.color = '#888';
            savedBeltsList.appendChild(noBeltMessage);
            updateBulkActionButtonsState(); // ★ベルトがない場合もボタン状態を更新
            return;
        }
        beltsToRender.forEach((beltData) => {
            const { effects, locked, memo } = beltData;
            const categoryEffect = effects[0] || '効果なし';
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            const categoryClassName = categoryClassMap[categoryEffect] || 'category-default';
            beltItem.classList.add(categoryClassName);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'belt-selector';
            checkbox.dataset.effectsJson = JSON.stringify(effects);
            checkbox.addEventListener('change', () => {
                beltItem.classList.toggle('selected', checkbox.checked);
                updateBulkActionButtonsState();
            });
            beltItem.appendChild(checkbox);

            const beltInfo = document.createElement('div');
            beltInfo.className = 'saved-belt-info';
            beltInfo.addEventListener('click', () => loadBelt(effects));
            const validEffects = effects.filter(e => e !== '効果なし');
            validEffects.forEach(effect => { const effectSpan = document.createElement('span'); effectSpan.textContent = effect; beltInfo.appendChild(effectSpan); });
            if (memo) { const memoSpan = document.createElement('span'); memoSpan.className = 'belt-memo'; memoSpan.textContent = `📝 ${memo}`; beltInfo.appendChild(memoSpan); }
            const actionButtons = document.createElement('div');
            actionButtons.className = 'saved-belt-actions';
            const upperActions = document.createElement('div');
            upperActions.className = 'saved-belt-actions-upper';
            const lockButton = document.createElement('button');
            lockButton.className = 'saved-belt-lock'; lockButton.textContent = locked ? '解除' : 'ロック';
            lockButton.addEventListener('click', (e) => { e.stopPropagation(); toggleLockState(effects); });
            const deleteButton = document.createElement('button');
            deleteButton.className = 'saved-belt-delete'; deleteButton.textContent = '削除'; deleteButton.disabled = locked;
            deleteButton.addEventListener('click', (e) => { e.stopPropagation(); deleteBelt(effects); });
            upperActions.appendChild(lockButton);
            upperActions.appendChild(deleteButton);
            const memoEditButton = document.createElement('button');
            memoEditButton.className = 'saved-belt-memo-edit'; memoEditButton.textContent = 'メモ編集';
            memoEditButton.addEventListener('click', (e) => { e.stopPropagation(); editMemo(effects); });
            actionButtons.appendChild(upperActions);
            actionButtons.appendChild(memoEditButton);
            beltItem.appendChild(beltInfo);
            beltItem.appendChild(actionButtons);
            savedBeltsList.appendChild(beltItem);
        });
        updateBulkActionButtonsState();
    }
    
    // === プルダウン選択肢の生成・更新 ===
    function rebuildOptionFragments() { /* 省略 (変更なし) */ fullOptionsFragment = document.createDocumentFragment(); categoryOptionsFragment = document.createDocumentFragment(); effectOptionsFragment = document.createDocumentFragment(); const sealedGroups = getSealedGroups(); for (const effectName in ALL_EFFECTS_DATA) { if (isEffectSealed(effectName, sealedGroups)) continue; const option = document.createElement("option"); option.value = effectName; option.textContent = effectName; fullOptionsFragment.appendChild(option.cloneNode(true)); if (effectName.includes("(カテゴリー用)") || effectName === "効果なし") { categoryOptionsFragment.appendChild(option.cloneNode(true)); } if (!effectName.includes("(カテゴリー用)") || effectName === "効果なし") { effectOptionsFragment.appendChild(option.cloneNode(true)); } } }
    function updateAllSelectOptions() { /* 省略 (変更なし) */ rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const currentValue = select.value; const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.innerHTML = ""; select.appendChild(sourceFragment.cloneNode(true)); if (Array.from(select.options).some(o => o.value === currentValue)) { select.value = currentValue; } else { select.value = "効果なし"; } }); updateAndSort(); }
    
    // === 並び替え・フィルタリングのメイン関数 ===
    function updateAndSort() { /* 省略 (変更なし) */ if (isSorting) return; isSorting = true; const allSelects = Array.from(container.querySelectorAll('select')); const searchInputs = Array.from(container.querySelectorAll('.effect-search')); const originalValues = allSelects.map(s => s.value); const categoryValue = originalValues[0]; const effectsForSorting = originalValues.slice(1); const sortedEffects = [...effectsForSorting].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0)); const finalValues = [categoryValue, ...sortedEffects]; allSelects.forEach((select, currentIndex) => { const finalValueForThisSelect = finalValues[currentIndex]; const searchTerm = searchInputs[currentIndex] ? searchInputs[currentIndex].value.toLowerCase() : ''; const otherUsedGroupKeys = new Set(); finalValues.forEach((value, index) => { if (currentIndex !== index && value !== '効果なし') { const groupKey = getGroupKeyForEffect(value); if (groupKey) { otherUsedGroupKeys.add(groupKey); } } }); const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment; const newOptionsFragment = document.createDocumentFragment(); Array.from(sourceFragment.children).forEach(optionNode => { const optionValue = optionNode.value; const optionGroupKey = getGroupKeyForEffect(optionValue); const optionText = optionNode.textContent.toLowerCase(); const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === finalValueForThisSelect; const matchesSearch = !searchTerm || optionText.includes(searchTerm); if (isSelectableByGroup && matchesSearch) { newOptionsFragment.appendChild(optionNode.cloneNode(true)); } }); select.innerHTML = ''; select.appendChild(newOptionsFragment); const valueExists = Array.from(select.options).some(opt => opt.value === finalValueForThisSelect); if (!valueExists && finalValueForThisSelect !== '効果なし') { const restoredOption = document.createElement('option'); restoredOption.value = finalValueForThisSelect; restoredOption.textContent = finalValueForThisSelect; select.insertBefore(restoredOption, select.firstChild); } select.value = finalValueForThisSelect; }); const totalScore = calculateTotalScore(finalValues); document.getElementById("totalScore").textContent = `合計点数: ${totalScore.toFixed(1)}`; isSorting = false; }
    
    // === 表示更新・フィルタリング・ソート ===
    function updateDisplay() { /* 省略 (変更なし) */ let allBelts = getSavedBelts(); let beltsWithScore = allBelts.map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) })); const filterRange = FILTERS[currentFilter]; let filteredBelts = beltsWithScore.filter(belt => filterRange && belt.score >= filterRange.min && belt.score <= filterRange.max); filteredBelts.sort((a, b) => currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score); renderSavedBelts(filteredBelts); updateActiveButtons(); }
    function updateActiveButtons() { /* 省略 (変更なし) */ filterButtonGroup.querySelectorAll("button").forEach(btn => { btn.classList.toggle("active", btn.dataset.filter === currentFilter); }); sortButtonGroup.querySelectorAll("button").forEach(btn => { const sortType = btn.id; btn.classList.toggle("active", (sortType === "sortDivine" && currentSortDirection === "divine") || (sortType === "sortTrash" && currentSortDirection === "trash")); }); }
    function loadBelt(effects) { /* 省略 (変更なし) */ const selects = container.querySelectorAll('select'); const searchInputs = container.querySelectorAll('.effect-search'); searchInputs.forEach(input => { input.value = ""; }); selects.forEach((select, index) => { select.value = effects[index] || '効果なし'; }); updateAndSort(); window.scrollTo(0, 0); }
    
    // ★★★ここから一括操作関連の関数★★★
    function setupBulkActionButtons() {
        bulkActionsContainer.innerHTML = '';
        selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'すべて選択';
        selectAllButton.addEventListener('click', toggleSelectAll);

        lockSelectedButton = document.createElement('button');
        lockSelectedButton.textContent = '選択をロック';
        lockSelectedButton.addEventListener('click', lockSelectedBelts);

        // ★「選択を解除」ボタンを追加
        unlockSelectedButton = document.createElement('button');
        unlockSelectedButton.textContent = '選択をロック解除';
        unlockSelectedButton.addEventListener('click', unlockSelectedBelts);

        deleteSelectedButton = document.createElement('button');
        deleteSelectedButton.textContent = '選択を削除（ロックを除く）';
        deleteSelectedButton.addEventListener('click', deleteSelectedBelts);
        
        lockAllButton = document.createElement('button');
        lockAllButton.textContent = 'すべてロック';
        lockAllButton.addEventListener('click', lockAllBelts);

        // ★「すべて解除」ボタンを追加
        unlockAllButton = document.createElement('button');
        unlockAllButton.textContent = 'すべてロック解除';
        unlockAllButton.addEventListener('click', unlockAllBelts);

        deleteAllUnlockedButton = document.createElement('button');
        deleteAllUnlockedButton.id = 'deleteAllUnlockedButton';
        deleteAllUnlockedButton.textContent = '全削除(ロック除く)';
        deleteAllUnlockedButton.addEventListener('click', deleteAllUnlockedBelts);

        bulkActionsContainer.append(selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton);
    }

    function updateBulkActionButtonsState() {
        const selectedCount = savedBeltsList.querySelectorAll('.belt-selector:checked').length;
        const totalCount = savedBeltsList.querySelectorAll('.belt-selector').length;

        lockSelectedButton.disabled = selectedCount === 0;
        unlockSelectedButton.disabled = selectedCount === 0; // ★ボタンの状態を更新
        deleteSelectedButton.disabled = selectedCount === 0;

        if (totalCount === 0) {
            selectAllButton.textContent = 'すべて選択';
            selectAllButton.disabled = true;
        } else {
            selectAllButton.disabled = false;
            if (selectedCount === 0) {
                selectAllButton.textContent = 'すべて選択';
            } else if (selectedCount === totalCount) {
                selectAllButton.textContent = 'すべて解除';
            } else {
                selectAllButton.textContent = `選択中 ${selectedCount}`;
            }
        }
    }

    function toggleSelectAll() {
        const checkboxes = savedBeltsList.querySelectorAll('.belt-selector');
        const shouldSelectAll = Array.from(checkboxes).some(cb => !cb.checked);
        checkboxes.forEach(cb => {
            if (cb.checked !== shouldSelectAll) {
                cb.checked = shouldSelectAll;
                cb.closest('.saved-belt-item').classList.toggle('selected', shouldSelectAll);
            }
        });
        updateBulkActionButtonsState();
    }
    
    function getSelectedEffectsJson() {
        const checkedBoxes = savedBeltsList.querySelectorAll('.belt-selector:checked');
        return Array.from(checkedBoxes).map(cb => cb.dataset.effectsJson);
    }

    function lockSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        if (confirm(`選択した ${selectedEffects.length} 個のベルトをロックしますか？`)) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if (selectedEffects.includes(JSON.stringify(belt.effects)) && !belt.locked) {
                    belt.locked = true;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} 個のベルトをロックしました。`);
                updateDisplay();
            } else {
                showToast(`ロック対象のベルトはありませんでした。`);
            }
        }
    }
    
    // ★「選択を解除」機能を追加
    function unlockSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        if (confirm(`選択した ${selectedEffects.length} 個のベルトのロックを解除しますか？`)) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if (selectedEffects.includes(JSON.stringify(belt.effects)) && belt.locked) {
                    belt.locked = false;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} 個のベルトのロックを解除しました。`);
                updateDisplay();
            } else {
                showToast(`ロック解除対象のベルトはありませんでした。`);
            }
        }
    }

    function deleteSelectedBelts() {
        const selectedEffects = getSelectedEffectsJson();
        if (selectedEffects.length === 0) return;

        let savedBelts = getSavedBelts();
        const selectedBeltsData = savedBelts.filter(b => selectedEffects.includes(JSON.stringify(b.effects)));
        const unlockedToDelete = selectedBeltsData.filter(b => !b.locked);
        const lockedCount = selectedBeltsData.length - unlockedToDelete.length;

        if (unlockedToDelete.length === 0) {
            showToast('削除対象のベルトがありません。(ロックされているベルトは削除できません)');
            return;
        }

        let confirmMsg = `選択した ${unlockedToDelete.length} 個のベルトを削除しますか？`;
        if (lockedCount > 0) {
            confirmMsg += `\n\n(注意: ロックされている ${lockedCount} 個のベルトは削除されません)`;
        }

        if (confirm(confirmMsg)) {
            const unlockedToDeleteSet = new Set(unlockedToDelete.map(b => JSON.stringify(b.effects)));
            const updatedBelts = savedBelts.filter(b => !unlockedToDeleteSet.has(JSON.stringify(b.effects)));
            localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts));
            showToast(`${unlockedToDelete.length} 個のベルトを削除しました。`);
            updateDisplay();
        }
    }
    
    function lockAllBelts() {
        if(confirm('保存されているすべてのベルトをロックしますか？')) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if(!belt.locked) {
                    belt.locked = true;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} 個のベルトをロックしました。`);
                updateDisplay();
            } else {
                showToast('すべてのベルトは既にロックされています。');
            }
        }
    }

    // ★「すべて解除」機能を追加
    function unlockAllBelts() {
        if(confirm('保存されているすべてのベルトのロックを解除しますか？')) {
            let savedBelts = getSavedBelts();
            let changedCount = 0;
            savedBelts.forEach(belt => {
                if(belt.locked) {
                    belt.locked = false;
                    changedCount++;
                }
            });
            if (changedCount > 0) {
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast(`${changedCount} 個のベルトのロックを解除しました。`);
                updateDisplay();
            } else {
                showToast('ロックされているベルトはありませんでした。');
            }
        }
    }

    function deleteAllUnlockedBelts() {
        let savedBelts = getSavedBelts();
        const unlockedCount = savedBelts.filter(b => !b.locked).length;

        if (unlockedCount === 0) {
            showToast('削除対象のベルト(ロックされていないベルト)がありません。');
            return;
        }

        if (confirm(`【危険】ロックされていない ${unlockedCount} 個のベルトをすべて削除しますか？\nこの操作は元に戻すことができません！`)) {
            const confirmationText = 'delete';
            const userInput = prompt(`本当に削除する場合は、「${confirmationText}」と入力してください。`);
            if (userInput === confirmationText) {
                const updatedBelts = savedBelts.filter(b => b.locked);
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts));
                showToast(`ロックされていない ${unlockedCount} 個のベルトをすべて削除しました。`);
                updateDisplay();
            } else {
                showToast('入力が一致しなかったため、削除をキャンセルしました。');
            }
        }
    }


    // === 初期化処理 ===
    function generateSealableGroups() { /* 省略 (変更なし) */ const groups = new Map(); function addGroup(name, score) { const key = name.replace(/\+\?%?/, '').trim(); if (!groups.has(key)) { groups.set(key, { group: name, score: score }); } } addGroup("こうげき力+?", ALL_EFFECTS_DATA["こうげき力+25"]); addGroup("こうげき魔力と回復魔力+?", ALL_EFFECTS_DATA["こうげき魔力と回復魔力+50"]); addGroup("会心率と呪文暴走率+?%", ALL_EFFECTS_DATA["会心率と呪文暴走率+2.0%"]); WEAPON_NAMES.forEach(weapon => { const baseScore = WEAPON_EFFECTS[weapon]; ELEMENTS.forEach(element => { addGroup(`${weapon}装備時 ${element}の攻撃ダメージ+?%`, baseScore + 3); }); }); Object.keys(MONSTER_TYPES).forEach(type => { const baseScore = MONSTER_TYPES[type]; addGroup(`${type}にダメージ+?%`, baseScore + 3); }); addGroup("盾装備で開戦時○○系", ALL_EFFECTS_DATA["盾装備で開戦時○○系"]); const sortedGroups = Array.from(groups.values()).sort((a, b) => { if (b.score !== a.score) return b.score - a.score; return a.group.localeCompare(b.group, 'ja'); }); sealableGroups = sortedGroups.map(g => g.group); }
    function createEffectSelects() { /* 省略 (変更なし) */ const labels = ["カテゴリー", "効果 1", "効果 2", "効果 3", "効果 4", "効果 5"]; labels.forEach((labelText, index) => { const block = document.createElement("div"); block.className = "effect-block"; const label = document.createElement("label"); label.textContent = labelText; const searchInput = document.createElement("input"); searchInput.type = "text"; searchInput.className = "effect-search"; searchInput.placeholder = "効果を検索して絞り込み..."; const select = document.createElement("select"); select.dataset.type = index === 0 ? "category" : "effect"; select.addEventListener("change", updateAndSort); searchInput.addEventListener("input", updateAndSort); block.appendChild(label); block.appendChild(searchInput); block.appendChild(select); container.appendChild(block); }); rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.appendChild(sourceFragment.cloneNode(true)); }); }
    function createFilterButtons() { /* 省略 (変更なし) */ filterButtonGroup.innerHTML = ""; const filterConfigs = [ { filter: "all", text: "すべて表示" }, { filter: "general", text: "汎用ベルト" }, ...WEAPON_NAMES.map(name => ({ filter: name, text: `${name}用` })), { filter: "pending", text: "保留中のベルト" }, { filter: "storage", text: "取り敢えず収納" } ]; filterConfigs.forEach(({ filter, text }) => { const button = document.createElement("button"); button.dataset.filter = filter; button.textContent = text; button.addEventListener("click", () => { currentFilter = button.dataset.filter; updateDisplay(); }); filterButtonGroup.appendChild(button); }); }

    document.addEventListener('DOMContentLoaded', () => {
        migrateSavedBelts();
        generateSealableGroups();
        createEffectSelects();
        createFilterButtons();
        setupBulkActionButtons();
        updateAndSort();
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', (e) => { if (e.target === sealModal) sealModal.style.display = 'none'; });
        updateDisplay();
    });
  </script>
</body>
</html>

