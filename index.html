<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>戦神のベルト管理ツール (ver1.5)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectとの間に少し余白 */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* 合計点数を非表示に */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }

    /* カテゴリーごとの色を定義 */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } /* 片手剣 */
    .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } /* 両手剣 */
    .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } /* 短剣 */
    /* ★★★変更点２：不足していた武器カテゴリの色を追加★★★ */
    .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } /* スティック */
    .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } /* 両手杖 */
    .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } /* ヤリ */
    .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } /* オノ */
    .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } /* 棍 */
    .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } /* ツメ */
    .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } /* ムチ */
    .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } /* 扇 */
    .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } /* ハンマー */
    .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } /* ブーメラン */
    .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } /* 弓 */
    .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; } /* 鎌 */
    
    /* 封印設定モーダル用のスタイル */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* トースト通知用のスタイル */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>戦神のベルト管理ツール</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">合計点数: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">封印効果の管理</button>
    <button id="saveButton">現在のベルトを保存</button>
  </div>

  <div id="savedBeltsSection">
    <h2>保存されたベルト<span id="savedBeltsCount"></span></h2>
    <div id="filterButtonGroup" class="action-button-group"></div>
    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">神ベルト順</button>
      <button id="sortTrash">ゴミベルト順</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>封印効果の管理</span><span id="sealedCount"></span></h2>
        <p>封印したい効果にチェックを入れてください。チェックした効果は、効果選択のプルダウンに表示されなくなります。選択後、保存するボタンを押してください。</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">キャンセル</button>
            <button id="saveSealSettingsButton">保存する</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    const DATA_VERSION = '1.5'; // 機能修正のためバージョンアップ
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';

    const WEAPON_EFFECTS = { "片手剣": 18, "両手剣": 17.9, "短剣": 17.8, "スティック": 17.7, "両手杖": 17.6, "ヤリ": 17.5, "オノ": 17.4, "棍": 17.3, "ツメ": 17.2, "ムチ": 17.1, "扇": 17.0, "ハンマー": 16.9, "ブーメラン": 16.8, "弓": 16.7, "鎌": 16.6 };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const ELEMENTS = ["炎", "氷", "風", "雷", "土", "闇", "光"];
    const MONSTER_TYPES = { "ドラゴン系": 16.5, "虫系": 16.4, "獣系": 16.3, "ゾンビ系": 16.2, "植物系": 16.1, "怪人系": 16.0, "悪魔系": 15.9, "エレ系": 15.8, "鳥系": 15.7, "物質系": 15.6, "スライム系": 15.5, "マシン系": 15.4, "水系": 15.3 };
    function createAllEffectsData() {
        const categoryScores = { "汎用ベルト (カテゴリー用)": 40000, "保留中のベルト (カテゴリー用)": 6000, "取り敢えず収納 (カテゴリー用)": 4000 };
        let weaponScore = 38000;
        WEAPON_NAMES.forEach(name => { categoryScores[`${name}用ベルト (カテゴリー用)`] = weaponScore; weaponScore -= 2000; });
        const effectScores = { "効果なし": -30, "こうげき力+15": 15, "こうげき力+20": 21.8, "こうげき力+25": 22, "こうげき魔力と回復魔力+30": 14.9, "こうげき魔力と回復魔力+40": 21.7, "こうげき魔力と回復魔力+50": 21.9, "会心率と呪文暴走率+1.0%": 14.8, "会心率と呪文暴走率+1.5%": 21.7, "会心率と呪文暴走率+2.0%": 21.8, "盾装備で開戦時○○系": 0.05 };
        Object.keys(WEAPON_EFFECTS).forEach(weapon => {
            const baseScore = WEAPON_EFFECTS[weapon];
            ELEMENTS.forEach(element => { [12, 13, 14, 15].forEach(val => { effectScores[`${weapon}装備時 ${element}の攻撃ダメージ+${val}%`] = baseScore + (val - 12); }); });
        });
        Object.keys(MONSTER_TYPES).forEach(type => {
            const baseScore = MONSTER_TYPES[type];
            for(let i = 0; i < 4; i++) { effectScores[`${type}にダメージ+${9+i}%`] = baseScore + i; }
        });
        return { ...categoryScores, ...effectScores };
    }
    const ALL_EFFECTS_DATA = createAllEffectsData();
    let sealableGroups = [];
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    function createFilters() {
        const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } };
        let weaponScore = 38000;
        WEAPON_NAMES.forEach(name => { const minScore = weaponScore - 2000; filters[name] = { min: minScore + 1849, max: weaponScore + 1848 }; weaponScore -= 2000; });
        return filters;
    }
    const FILTERS = createFilters();
    let currentFilter = 'all';
    let currentSortDirection = 'divine';

    // === DOM要素の取得 ===
    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    const sealSettingsButton = document.getElementById('sealSettingsButton');
    const sealModal = document.getElementById('sealModal');
    const sealActionButtonsContainer = document.getElementById('sealActionButtons');
    const sealGroupsContainer = document.getElementById('sealGroupsContainer');
    const saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
    const cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
    const sealedCountElement = document.getElementById('sealedCount');
    const toastContainer = document.getElementById('toast-container');
    
    function showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        toastContainer.appendChild(toast);
        setTimeout(() => { toast.classList.add('show'); }, 10);
        setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000);
    }
    
    function populateSealModal() {
        sealActionButtonsContainer.innerHTML = '';
        const selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'すべて選択';
        selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); });
        const deselectAllButton = document.createElement('button');
        deselectAllButton.textContent = 'すべて解除';
        deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); });
        sealActionButtonsContainer.appendChild(selectAllButton);
        sealActionButtonsContainer.appendChild(deselectAllButton);
        sealGroupsContainer.innerHTML = '';
        const sealedGroups = getSealedGroups();
        sealableGroups.forEach(group => {
            const div = document.createElement('div');
            div.className = 'seal-group';
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group);
            checkbox.addEventListener('change', updateSealedCount);
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(group));
            div.appendChild(label);
            sealGroupsContainer.appendChild(div);
        });
        updateSealedCount();
    }

    function saveSealSettings() {
        const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked');
        const sealedGroups = Array.from(checkboxes).map(cb => cb.value);
        localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups));
        sealModal.style.display = 'none';
        updateAllSelectOptions();
        showToast("封印設定を保存しました。");
    }

    function updateAllSelectOptions() {
        rebuildOptionFragments();
        const selects = document.querySelectorAll("#effectsContainer select");
        selects.forEach(select => {
            const currentValue = select.value;
            const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment;
            select.innerHTML = "";
            select.appendChild(sourceFragment.cloneNode(true));
            if (Array.from(select.options).some(o => o.value === currentValue)) {
                select.value = currentValue;
            } else {
                select.value = "効果なし";
            }
        });
        updateAndSort();
    }
    
    function getGroupKeyForEffect(effect) {
        if (!effect || effect === '効果なし' || effect.includes('(カテゴリー用)')) { return null; }
        const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim();
        if (key && key !== effect) { return key; }
        return effect;
    }

    function migrateSavedBelts() { /* 省略 (変更なし) */ }
    function saveCurrentBelt() { /* 省略 (変更なし) */ }
    function deleteBelt(effectsToDelete) { /* 省略 (変更なし) */ }
    function editMemo(effectsToEdit) { /* 省略 (変更なし) */ }
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(表示: ${beltsToRender.length}個 / 合計: ${totalSavedCount}個)`;
        const categoryClassMap={"汎用ベルト (カテゴリー用)": "category-general", "保留中のベルト (カテゴリー用)": "category-pending", "取り敢えず収納 (カテゴリー用)": "category-storage"};
        WEAPON_NAMES.forEach((n,i)=>{categoryClassMap[`${n}用ベルト (カテゴリー用)`]=`category-weapon-${i}`});
        beltsToRender.forEach((beltData) => {
            const { effects, locked, memo } = beltData;
            const categoryEffect = effects[0] || '効果なし';
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            const categoryClassName = categoryClassMap[categoryEffect] || 'category-default';
            beltItem.classList.add(categoryClassName);
            const beltInfo = document.createElement('div');
            beltInfo.className = 'saved-belt-info';
            beltInfo.addEventListener('click', () => loadBelt(effects));
            const validEffects = effects.filter(e => e !== '効果なし');
            validEffects.forEach(effect => { const effectSpan = document.createElement('span'); effectSpan.textContent = effect; beltInfo.appendChild(effectSpan); });
            if (memo) { const memoSpan = document.createElement('span'); memoSpan.className = 'belt-memo'; memoSpan.textContent = `📝 ${memo}`; beltInfo.appendChild(memoSpan); }
            const actionButtons = document.createElement('div');
            actionButtons.className = 'saved-belt-actions';
            const upperActions = document.createElement('div');
            upperActions.className = 'saved-belt-actions-upper';
            const lockButton = document.createElement('button');
            lockButton.className = 'saved-belt-lock'; lockButton.textContent = locked ? '解除' : 'ロック';
            lockButton.addEventListener('click', (e) => { e.stopPropagation(); toggleLockState(effects); });
            const deleteButton = document.createElement('button');
            deleteButton.className = 'saved-belt-delete'; deleteButton.textContent = '削除'; deleteButton.disabled = locked;
            deleteButton.addEventListener('click', (e) => { e.stopPropagation(); deleteBelt(effects); });
            upperActions.appendChild(lockButton);
            upperActions.appendChild(deleteButton);
            const memoEditButton = document.createElement('button');
            memoEditButton.className = 'saved-belt-memo-edit'; memoEditButton.textContent = 'メモ編集';
            memoEditButton.addEventListener('click', (e) => { e.stopPropagation(); editMemo(effects); });
            actionButtons.appendChild(upperActions);
            actionButtons.appendChild(memoEditButton);
            beltItem.appendChild(beltInfo);
            beltItem.appendChild(actionButtons);
            savedBeltsList.appendChild(beltItem);
        });
    }
    
    function getSealedGroups(){const e=localStorage.getItem(SEALED_EFFECTS_KEY);return e?JSON.parse(e):[]}
    function isEffectSealed(e,t){return!(!t||0===t.length)&&t.some(t=>e.startsWith(t.replace(/\+\?%?/,"").replace("○○系","")))}
    function updateSealedCount(){if(sealableGroups&&0!==sealableGroups.length){const e=sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length,t=sealableGroups.length;sealedCountElement.textContent=`(${e} / ${t} 件 封印中)`}}
    function rebuildOptionFragments(){fullOptionsFragment=document.createDocumentFragment(),categoryOptionsFragment=document.createDocumentFragment(),effectOptionsFragment=document.createDocumentFragment();const e=getSealedGroups();for(let t in ALL_EFFECTS_DATA){if(isEffectSealed(t,e))continue;const a=document.createElement("option");a.value=t,a.textContent=t,fullOptionsFragment.appendChild(a.cloneNode(!0)),(t.includes("(カテゴリー用)")||"効果なし"===t)&&categoryOptionsFragment.appendChild(a.cloneNode(!0)),t.includes("(カテゴリー用)")&&"効果なし"!==t||effectOptionsFragment.appendChild(a.cloneNode(!0))}}
    
    function createEffectSelects(){const e=["カテゴリー","効果 1","効果 2","効果 3","効果 4","効果 5"];for(let t=0;t<6;t++){const a=document.createElement("div");a.className="effect-block";const n=document.createElement("label");n.textContent=e[t];const o=document.createElement("input");o.type="text",o.className="effect-search",o.placeholder="効果を検索して絞り込み...";const l=document.createElement("select");l.dataset.type=0===t?"category":"effect",l.addEventListener("change",updateAndSort),o.addEventListener("input",updateAndSort),a.appendChild(n),a.appendChild(o),a.appendChild(l),container.appendChild(a)}updateAllSelectOptions()}
    function createFilterButtons(){filterButtonGroup.innerHTML="";const e=[{filter:"all",text:"すべて表示"},{filter:"general",text:"汎用ベルト"},...WEAPON_NAMES.map(e=>({filter:e,text:`${e}用`})),{filter:"pending",text:"保留中のベルト"},{filter:"storage",text:"取り敢えず収納"}];e.forEach(({filter:e,text:t})=>{const a=document.createElement("button");a.dataset.filter=e,a.textContent=t,a.addEventListener("click",()=>{currentFilter=a.dataset.filter,updateDisplay()}),filterButtonGroup.appendChild(a)})}
    
    // ★★★変更点１：自動ソート機能を復活させ、グループ制約と両立するように修正★★★
    let isSorting = false; // イベントの無限ループを防ぐためのフラグ
    function updateAndSort() {
        if (isSorting) return;
        isSorting = true;

        // --- 自動ソート処理 ---
        const effectSelects = Array.from(container.querySelectorAll('select[data-type="effect"]'));
        const effectValues = effectSelects.map(s => s.value);
        const sortedValues = [...effectValues].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));

        // ソート結果を各プルダウンに反映させる
        effectSelects.forEach((select, index) => {
            select.value = sortedValues[index];
        });

        // --- 選択肢の動的更新処理 ---
        const allSelects = Array.from(container.querySelectorAll('select'));
        const searchInputs = Array.from(container.querySelectorAll('.effect-search'));
        const currentAllValues = allSelects.map(s => s.value); // ソート後の最新の値を取得

        const usedGroupKeys = new Set();
        currentAllValues.forEach(value => {
            if (value !== '効果なし') {
                const groupKey = getGroupKeyForEffect(value);
                if (groupKey) { usedGroupKeys.add(groupKey); }
            }
        });

        allSelects.forEach((select, index) => {
            const currentValue = select.value;
            const currentGroupKey = getGroupKeyForEffect(currentValue);
            const searchTerm = searchInputs[index] ? searchInputs[index].value.toLowerCase() : '';
            const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();
            
            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const optionText = optionNode.textContent.toLowerCase();
                const isSelectableByGroup = !optionGroupKey || optionGroupKey === currentGroupKey || !usedGroupKeys.has(optionGroupKey);
                const matchesSearch = !searchTerm || optionText.includes(searchTerm);
                if (isSelectableByGroup && matchesSearch) {
                    newOptionsFragment.appendChild(optionNode.cloneNode(true));
                }
            });
            
            select.innerHTML = '';
            select.appendChild(newOptionsFragment);
            
            const valueExists = Array.from(select.options).some(opt => opt.value === currentValue);
            if (!valueExists && currentValue !== '効果なし') {
                const restoredOption = document.createElement('option');
                restoredOption.value = currentValue;
                restoredOption.textContent = currentValue;
                select.insertBefore(restoredOption, select.firstChild);
            }
            select.value = currentValue;
        });

        // --- スコア計算 ---
        let totalScore = 0;
        allSelects.forEach(select => {
            totalScore += ALL_EFFECTS_DATA[select.value] || 0;
        });
        document.getElementById("totalScore").textContent = `合計点数: ${totalScore.toFixed(1)}`;

        isSorting = false; // 処理完了後にフラグを解除
    }
    
    function getSavedBelts(e=!1){const t=localStorage.getItem(SAVED_BELTS_KEY);return e?t?JSON.parse(t):[]:t?JSON.parse(t):[]}
    function calculateTotalScore(e){return e.reduce((e,t)=>e+(ALL_EFFECTS_DATA[t]||0),0)}
    function updateDisplay(){let e=getSavedBelts();let t=e.map(e=>({...e,score:calculateTotalScore(e.effects)}));const a=FILTERS[currentFilter],n=t.filter(e=>a&&e.score>=a.min&&e.score<=a.max);n.sort((e,t)=>"divine"===currentSortDirection?t.score-e.score:e.score-t.score),renderSavedBelts(n),updateActiveButtons()}
    function toggleLockState(e){let t=getSavedBelts();const a=JSON.stringify(e),n=t.find(e=>JSON.stringify(e.effects)===a);n&&(n.locked=!n.locked,localStorage.setItem(SAVED_BELTS_KEY,JSON.stringify(t)),updateDisplay(),showToast(n.locked?"ベルトをロックしました。":"ベルトのロックを解除しました。"))}
    function updateActiveButtons(){filterButtonGroup.querySelectorAll("button").forEach(e=>{e.classList.toggle("active",e.dataset.filter===currentFilter)}),sortButtonGroup.querySelectorAll("button").forEach(e=>{const t=e.id;e.classList.toggle("active","sortDivine"===t&&"divine"===currentSortDirection||"sortTrash"===t&&"trash"===currentSortDirection)})}
    function loadBelt(e){const t=container.querySelectorAll("select"),a=container.querySelectorAll(".effect-search");a.forEach((e)=>{e.value=""}),t.forEach((t,a)=>{t.value=e[a]||"効果なし"}),updateAndSort(),window.scrollTo(0,0)}
    function generateSealableGroups(){const e=[];e.push({group:"こうげき力+?",score:ALL_EFFECTS_DATA["こうげき力+25"]}),e.push({group:"こうげき魔力と回復魔力+?",score:ALL_EFFECTS_DATA["こうげき魔力と回復魔力+50"]}),e.push({group:"会心率と呪文暴走率+?%",score:ALL_EFFECTS_DATA["会心率と呪文暴走率+2.0%"]}),WEAPON_NAMES.forEach(t=>{const a=WEAPON_EFFECTS[t];ELEMENTS.forEach(n=>{e.push({group:`${t}装備時 ${n}の攻撃ダメージ+?%`,score:a+3})})}),Object.keys(MONSTER_TYPES).forEach(t=>{const a=MONSTER_TYPES[t];e.push({group:`${t}にダメージ+?%`,score:a+3})}),e.push({group:"盾装備で開戦時○○系",score:ALL_EFFECTS_DATA["盾装備で開戦時○○系"]}),e.sort((e,t)=>{if(t.score!==e.score)return t.score-e.score;e.group.localeCompare(t.group,"ja")}),sealableGroups=e.map(e=>e.group)}

    document.addEventListener('DOMContentLoaded', () => {
        // (初期化処理の関数は長いため、ここでは省略。内容は変更なし)
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion !== DATA_VERSION) {
            migrateSavedBelts();
        }
        generateSealableGroups();
        createEffectSelects();
        createFilterButtons();
        updateAndSort();
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', (e) => { if (e.target === sealModal) sealModal.style.display = 'none'; });
        updateDisplay();
    });
  </script>
</body>
</html>
