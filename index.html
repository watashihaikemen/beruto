<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ« å†ä¿®æ­£(ver1.7)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* åˆè¨ˆç‚¹æ•°ã‚’éè¡¨ç¤ºã« */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }
    .saved-belt-info span { display: block; font-size: 14px; color: #666; margin-top: 4px; }
    .belt-memo { font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }
    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }

    /* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã”ã¨ã®è‰²ã‚’å®šç¾© */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } /* ç‰‡æ‰‹å‰£ */
    .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } /* ä¸¡æ‰‹å‰£ */
    .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } /* çŸ­å‰£ */
    .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } /* ã‚¹ãƒ†ã‚£ãƒƒã‚¯ */
    .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } /* ä¸¡æ‰‹æ– */
    .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } /* ãƒ¤ãƒª */
    .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } /* ã‚ªãƒ */
    .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } /* æ£ */
    .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } /* ãƒ„ãƒ¡ */
    .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } /* ãƒ ãƒ */
    .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } /* æ‰‡ */
    .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } /* ãƒãƒ³ãƒãƒ¼ */
    .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } /* ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³ */
    .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } /* å¼“ */
    .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; } /* éŒ */
    
    /* å°å°è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ«</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">åˆè¨ˆç‚¹æ•°: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">å°å°åŠ¹æœã®ç®¡ç†</button>
    <button id="saveButton">ç¾åœ¨ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜</button>
  </div>

  <div id="savedBeltsSection">
    <h2>ä¿å­˜ã•ã‚ŒãŸãƒ™ãƒ«ãƒˆ<span id="savedBeltsCount"></span></h2>
    <div id="filterButtonGroup" class="action-button-group"></div>
    <div class="action-button-group" id="sortButtonGroup">
      <button id="sortDivine">ç¥ãƒ™ãƒ«ãƒˆé †</button>
      <button id="sortTrash">ã‚´ãƒŸãƒ™ãƒ«ãƒˆé †</button>
    </div>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>å°å°åŠ¹æœã®ç®¡ç†</span><span id="sealedCount"></span></h2>
        <p>å°å°ã—ãŸã„åŠ¹æœã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚ãƒã‚§ãƒƒã‚¯ã—ãŸåŠ¹æœã¯ã€åŠ¹æœé¸æŠã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¡¨ç¤ºã•ã‚Œãªããªã‚Šã¾ã™ã€‚é¸æŠå¾Œã€ä¿å­˜ã™ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="saveSealSettingsButton">ä¿å­˜ã™ã‚‹</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’1.7ã«æ›´æ–°â˜…â˜…â˜…
    const DATA_VERSION = '1.7'; 
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';

    const WEAPON_EFFECTS = { "ç‰‡æ‰‹å‰£": 18, "ä¸¡æ‰‹å‰£": 17.9, "çŸ­å‰£": 17.8, "ã‚¹ãƒ†ã‚£ãƒƒã‚¯": 17.7, "ä¸¡æ‰‹æ–": 17.6, "ãƒ¤ãƒª": 17.5, "ã‚ªãƒ": 17.4, "æ£": 17.3, "ãƒ„ãƒ¡": 17.2, "ãƒ ãƒ": 17.1, "æ‰‡": 17.0, "ãƒãƒ³ãƒãƒ¼": 16.9, "ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³": 16.8, "å¼“": 16.7, "éŒ": 16.6 };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const ELEMENTS = ["ç‚", "æ°·", "é¢¨", "é›·", "åœŸ", "é—‡", "å…‰"];
    const MONSTER_TYPES = { "ãƒ‰ãƒ©ã‚´ãƒ³ç³»": 16.5, "è™«ç³»": 16.4, "ç£ç³»": 16.3, "ã‚¾ãƒ³ãƒ“ç³»": 16.2, "æ¤ç‰©ç³»": 16.1, "æ€ªäººç³»": 16.0, "æ‚ªé­”ç³»": 15.9, "ã‚¨ãƒ¬ç³»": 15.8, "é³¥ç³»": 15.7, "ç‰©è³ªç³»": 15.6, "ã‚¹ãƒ©ã‚¤ãƒ ç³»": 15.5, "ãƒã‚·ãƒ³ç³»": 15.4, "æ°´ç³»": 15.3 };
    
    function createAllEffectsData() {
        const categoryScores = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 40000, "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 6000, "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 4000 };
        let weaponScore = 38000;
        WEAPON_NAMES.forEach(name => { categoryScores[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = weaponScore; weaponScore -= 2000; });
        const effectScores = { "åŠ¹æœãªã—": -30, "ã“ã†ã’ãåŠ›+15": 15, "ã“ã†ã’ãåŠ›+20": 21.8, "ã“ã†ã’ãåŠ›+25": 22, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+30": 14.9, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+40": 21.7, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50": 21.9, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.0%": 14.8, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.5%": 21.7, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%": 21.8, "ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»": 0.05 };
        Object.keys(WEAPON_EFFECTS).forEach(weapon => {
            const baseScore = WEAPON_EFFECTS[weapon];
            ELEMENTS.forEach(element => { [12, 13, 14, 15].forEach(val => { effectScores[`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+${val}%`] = baseScore + (val - 12); }); });
        });
        Object.keys(MONSTER_TYPES).forEach(type => {
            const baseScore = MONSTER_TYPES[type];
            for(let i = 0; i < 4; i++) { effectScores[`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+${9+i}%`] = baseScore + i; }
        });
        return { ...categoryScores, ...effectScores };
    }
    const ALL_EFFECTS_DATA = createAllEffectsData();
    
    function createFilters() {
        const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } };
        let weaponScore = 38000;
        WEAPON_NAMES.forEach(name => { const minScore = weaponScore - 2000; filters[name] = { min: minScore + 1849, max: weaponScore + 1848 }; weaponScore -= 2000; });
        return filters;
    }
    const FILTERS = createFilters();

    // === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ===
    let sealableGroups = [];
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    let isSorting = false; // ã‚¤ãƒ™ãƒ³ãƒˆã®ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã®ãƒ•ãƒ©ã‚°

    // === DOMè¦ç´ ã®å–å¾— ===
    const container = document.getElementById('effectsContainer');
    const savedBeltsList = document.getElementById('savedBeltsList');
    const saveButton = document.getElementById('saveButton');
    const sortDivineButton = document.getElementById('sortDivine');
    const sortTrashButton = document.getElementById('sortTrash');
    const savedBeltsCountElement = document.getElementById('savedBeltsCount');
    const filterButtonGroup = document.getElementById('filterButtonGroup');
    const sortButtonGroup = document.getElementById('sortButtonGroup');
    const sealSettingsButton = document.getElementById('sealSettingsButton');
    const sealModal = document.getElementById('sealModal');
    const sealActionButtonsContainer = document.getElementById('sealActionButtons');
    const sealGroupsContainer = document.getElementById('sealGroupsContainer');
    const saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
    const cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
    const sealedCountElement = document.getElementById('sealedCount');
    const toastContainer = document.getElementById('toast-container');
    
    // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ===
    function showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        toastContainer.appendChild(toast);
        setTimeout(() => { toast.classList.add('show'); }, 10);
        setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000);
    }

    function getSavedBelts() {
        const beltsJSON = localStorage.getItem(SAVED_BELTS_KEY);
        return beltsJSON ? JSON.parse(beltsJSON) : [];
    }

    function calculateTotalScore(effects) {
        return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0);
    }
    
    function getGroupKeyForEffect(effect) {
        if (!effect || effect === 'åŠ¹æœãªã—' || effect.includes('(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)')) { return null; }
        const key = effect.replace(/(\s*\+[\d\.]+%?)$/, '').trim();
        if (key && key !== effect) { return key; }
        return effect;
    }

    // === å°å°æ©Ÿèƒ½é–¢é€£ ===
    function getSealedGroups() {
        const sealedJSON = localStorage.getItem(SEALED_EFFECTS_KEY);
        return sealedJSON ? JSON.parse(sealedJSON) : [];
    }

    function isEffectSealed(effect, sealedGroups) {
        if (!sealedGroups || sealedGroups.length === 0) return false;
        return sealedGroups.some(groupPrefix => effect.startsWith(groupPrefix.replace(/\+\?%?/, '').replace("â—‹â—‹ç³»", "")));
    }

    function updateSealedCount() {
        if (!sealableGroups || sealableGroups.length === 0) return;
        const checkedCount = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length;
        const totalCount = sealableGroups.length;
        sealedCountElement.textContent = `(${checkedCount} / ${totalCount} ä»¶ å°å°ä¸­)`;
    }
    
    function populateSealModal() {
        sealActionButtonsContainer.innerHTML = '';
        const selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ';
        selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); });
        const deselectAllButton = document.createElement('button');
        deselectAllButton.textContent = 'ã™ã¹ã¦è§£é™¤';
        deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); });
        sealActionButtonsContainer.appendChild(selectAllButton);
        sealActionButtonsContainer.appendChild(deselectAllButton);
        
        sealGroupsContainer.innerHTML = '';
        const sealedGroups = getSealedGroups();
        sealableGroups.forEach(group => {
            const div = document.createElement('div');
            div.className = 'seal-group';
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = group;
            checkbox.checked = sealedGroups.includes(group);
            checkbox.addEventListener('change', updateSealedCount);
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(group));
            div.appendChild(label);
            sealGroupsContainer.appendChild(div);
        });
        updateSealedCount();
    }

    function saveSealSettings() {
        const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked');
        const sealedGroups = Array.from(checkboxes).map(cb => cb.value);
        localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups));
        sealModal.style.display = 'none';
        updateAllSelectOptions();
        showToast("å°å°è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
    }

    // === ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç† (ä¿å­˜/å‰Šé™¤/æ›´æ–°) ===
    function migrateSavedBelts() {
        let savedBelts = getSavedBelts();
        if (savedBelts.length === 0) {
            localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
            return;
        }
        const migratedBelts = savedBelts.map(belt => {
            if (Array.isArray(belt)) {
                return { effects: belt, locked: false, memo: '' };
            }
            if (belt.locked === undefined) belt.locked = false;
            if (belt.memo === undefined) belt.memo = '';
            return belt;
        });
        localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(migratedBelts));
        localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
        console.log("ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ver " + DATA_VERSION + " ã«æ›´æ–°ã—ã¾ã—ãŸã€‚");
    }
    
    function saveCurrentBelt() {
        const selects = container.querySelectorAll('select');
        const currentEffects = Array.from(selects).map(s => s.value);
        const validEffectsCount = currentEffects.slice(1).filter(e => e !== 'åŠ¹æœãªã—').length;
        if (validEffectsCount < 1) {
            showToast("æœ‰åŠ¹ãªåŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚");
            return;
        }
        const savedBelts = getSavedBelts();
        const newBeltData = { effects: currentEffects, locked: false, memo: '' };
        const isDuplicate = savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects));
        if (isDuplicate) {
            showToast("ã“ã®åŠ¹æœã®çµ„ã¿åˆã‚ã›ã¯æ—¢ã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            return;
        }
        savedBelts.push(newBeltData);
        localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
        showToast("ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸï¼");
        updateDisplay();
    }

    function deleteBelt(effectsToDelete) {
        if (!confirm("ã“ã®ãƒ™ãƒ«ãƒˆã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
        let savedBelts = getSavedBelts();
        const effectsToDeleteStr = JSON.stringify(effectsToDelete);
        const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr);
        localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(updatedBelts));
        showToast("ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚");
        updateDisplay();
    }

    function editMemo(effectsToEdit) {
        let savedBelts = getSavedBelts();
        const effectsToEditStr = JSON.stringify(effectsToEdit);
        const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr);
        if (beltToEdit) {
            const newMemo = prompt("ãƒ™ãƒ«ãƒˆã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", beltToEdit.memo || "");
            if (newMemo !== null) {
                beltToEdit.memo = newMemo.trim();
                localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
                showToast("ãƒ¡ãƒ¢ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");
                updateDisplay();
            }
        }
    }
    
    function toggleLockState(effectsToToggle) {
        let savedBelts = getSavedBelts();
        const effectsToToggleStr = JSON.stringify(effectsToToggle);
        const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr);
        if (beltToToggle) {
            beltToToggle.locked = !beltToToggle.locked;
            localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(savedBelts));
            showToast(beltToToggle.locked ? "ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚" : "ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚");
            updateDisplay();
        }
    }

    // === è¡¨ç¤ºé–¢é€£ ===
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(è¡¨ç¤º: ${beltsToRender.length}å€‹ / åˆè¨ˆ: ${totalSavedCount}å€‹)`;
        const categoryClassMap = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-general", "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-pending", "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": "category-storage" };
        WEAPON_NAMES.forEach((name, index) => { categoryClassMap[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = `category-weapon-${index}`; });
        if (beltsToRender.length === 0) {
            const noBeltMessage = document.createElement('p');
            noBeltMessage.textContent = 'è¡¨ç¤ºå¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
            noBeltMessage.style.textAlign = 'center'; noBeltMessage.style.color = '#888';
            savedBeltsList.appendChild(noBeltMessage);
            return;
        }
        beltsToRender.forEach((beltData) => {
            const { effects, locked, memo } = beltData;
            const categoryEffect = effects[0] || 'åŠ¹æœãªã—';
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            const categoryClassName = categoryClassMap[categoryEffect] || 'category-default';
            beltItem.classList.add(categoryClassName);
            const beltInfo = document.createElement('div');
            beltInfo.className = 'saved-belt-info';
            beltInfo.addEventListener('click', () => loadBelt(effects));
            const validEffects = effects.filter(e => e !== 'åŠ¹æœãªã—');
            validEffects.forEach(effect => { const effectSpan = document.createElement('span'); effectSpan.textContent = effect; beltInfo.appendChild(effectSpan); });
            if (memo) { const memoSpan = document.createElement('span'); memoSpan.className = 'belt-memo'; memoSpan.textContent = `ğŸ“ ${memo}`; beltInfo.appendChild(memoSpan); }
            const actionButtons = document.createElement('div');
            actionButtons.className = 'saved-belt-actions';
            const upperActions = document.createElement('div');
            upperActions.className = 'saved-belt-actions-upper';
            const lockButton = document.createElement('button');
            lockButton.className = 'saved-belt-lock'; lockButton.textContent = locked ? 'è§£é™¤' : 'ãƒ­ãƒƒã‚¯';
            lockButton.addEventListener('click', (e) => { e.stopPropagation(); toggleLockState(effects); });
            const deleteButton = document.createElement('button');
            deleteButton.className = 'saved-belt-delete'; deleteButton.textContent = 'å‰Šé™¤'; deleteButton.disabled = locked;
            deleteButton.addEventListener('click', (e) => { e.stopPropagation(); deleteBelt(effects); });
            upperActions.appendChild(lockButton);
            upperActions.appendChild(deleteButton);
            const memoEditButton = document.createElement('button');
            memoEditButton.className = 'saved-belt-memo-edit'; memoEditButton.textContent = 'ãƒ¡ãƒ¢ç·¨é›†';
            memoEditButton.addEventListener('click', (e) => { e.stopPropagation(); editMemo(effects); });
            actionButtons.appendChild(upperActions);
            actionButtons.appendChild(memoEditButton);
            beltItem.appendChild(beltInfo);
            beltItem.appendChild(actionButtons);
            savedBeltsList.appendChild(beltItem);
        });
    }
    
    // === ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã®ç”Ÿæˆãƒ»æ›´æ–° ===
    function rebuildOptionFragments() {
        fullOptionsFragment = document.createDocumentFragment();
        categoryOptionsFragment = document.createDocumentFragment();
        effectOptionsFragment = document.createDocumentFragment();
        const sealedGroups = getSealedGroups();
        for (const effectName in ALL_EFFECTS_DATA) {
            if (isEffectSealed(effectName, sealedGroups)) continue;
            const option = document.createElement("option");
            option.value = effectName;
            option.textContent = effectName;
            fullOptionsFragment.appendChild(option.cloneNode(true));
            if (effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") {
                categoryOptionsFragment.appendChild(option.cloneNode(true));
            }
            if (!effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") {
                effectOptionsFragment.appendChild(option.cloneNode(true));
            }
        }
    }
    
    function updateAllSelectOptions() {
        rebuildOptionFragments();
        const selects = document.querySelectorAll("#effectsContainer select");
        selects.forEach(select => {
            const currentValue = select.value;
            const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment;
            select.innerHTML = "";
            select.appendChild(sourceFragment.cloneNode(true));
            if (Array.from(select.options).some(o => o.value === currentValue)) {
                select.value = currentValue;
            } else {
                select.value = "åŠ¹æœãªã—";
            }
        });
        updateAndSort();
    }
    
    function updateAndSort() {
        if (isSorting) return;
        isSorting = true;

        const allSelects = Array.from(container.querySelectorAll('select'));
        const searchInputs = Array.from(container.querySelectorAll('.effect-search'));
        
        // ç¾åœ¨ã®åŠ¹æœã®å€¤ã‚’ã™ã¹ã¦å–å¾—
        const allCurrentValues = allSelects.map(s => s.value);
        
        // ã‚«ãƒ†ã‚´ãƒªãƒ¼ä»¥å¤–ã®åŠ¹æœã‚’ã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆ
        const effectsForSorting = allCurrentValues.slice(1);
        const sortedEffects = [...effectsForSorting].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));

        // ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸå€¤ã‚’ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«åæ˜ 
        allSelects.slice(1).forEach((select, index) => {
            select.value = sortedEffects[index];
        });

        // æœ€æ–°ã®å€¤ã‚’å†åº¦å–å¾—
        const updatedValues = allSelects.map(s => s.value);
        
        // é¸æŠè‚¢ã®å‹•çš„æ›´æ–°
        allSelects.forEach((select, currentIndex) => {
            const currentValue = updatedValues[currentIndex];
            const searchTerm = searchInputs[currentIndex] ? searchInputs[currentIndex].value.toLowerCase() : '';

            // è‡ªåˆ†ä»¥å¤–ã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚­ãƒ¼ã‚’è¨ˆç®—
            const otherUsedGroupKeys = new Set();
            updatedValues.forEach((value, index) => {
                if (currentIndex !== index && value !== 'åŠ¹æœãªã—') {
                    const groupKey = getGroupKeyForEffect(value);
                    if (groupKey) {
                        otherUsedGroupKeys.add(groupKey);
                    }
                }
            });

            const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();
            const optionValues = new Set();
            
            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const optionText = optionNode.textContent.toLowerCase();

                // é¸æŠè‚¢ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === currentValue;
                const matchesSearch = !searchTerm || optionText.includes(searchTerm);

                if (isSelectableByGroup && matchesSearch && !optionValues.has(optionValue)) {
                    newOptionsFragment.appendChild(optionNode.cloneNode(true));
                    optionValues.add(optionValue);
                }
            });
            
            select.innerHTML = '';
            select.appendChild(newOptionsFragment);
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§é¸æŠè‚¢ã‹ã‚‰æ¶ˆãˆã¦ã‚‚ã€ç¾åœ¨ã®å€¤ã¯å¾©å…ƒã™ã‚‹
            const valueExists = Array.from(select.options).some(opt => opt.value === currentValue);
            if (!valueExists) {
                const restoredOption = document.createElement('option');
                restoredOption.value = currentValue;
                restoredOption.textContent = currentValue;
                select.insertBefore(restoredOption, select.firstChild);
            }
            select.value = currentValue;
        });

        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        let totalScore = 0;
        allSelects.forEach(select => {
            totalScore += ALL_EFFECTS_DATA[select.value] || 0;
        });
        document.getElementById("totalScore").textContent = `åˆè¨ˆç‚¹æ•°: ${totalScore.toFixed(1)}`;

        isSorting = false;
    }
    
    // === è¡¨ç¤ºæ›´æ–°ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆ ===
    function updateDisplay() {
        let allBelts = getSavedBelts();
        let beltsWithScore = allBelts.map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) }));
        const filterRange = FILTERS[currentFilter];
        let filteredBelts = beltsWithScore.filter(belt => filterRange && belt.score >= filterRange.min && belt.score <= filterRange.max);
        filteredBelts.sort((a, b) => currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score);
        renderSavedBelts(filteredBelts);
        updateActiveButtons();
    }
    
    function updateActiveButtons() {
        filterButtonGroup.querySelectorAll("button").forEach(btn => { btn.classList.toggle("active", btn.dataset.filter === currentFilter); });
        sortButtonGroup.querySelectorAll("button").forEach(btn => {
            const sortType = btn.id;
            btn.classList.toggle("active", (sortType === "sortDivine" && currentSortDirection === "divine") || (sortType === "sortTrash" && currentSortDirection === "trash"));
        });
    }

    function loadBelt(effects) {
        const selects = container.querySelectorAll('select');
        const searchInputs = container.querySelectorAll('.effect-search');
        searchInputs.forEach(input => { input.value = ""; });
        selects.forEach((select, index) => { select.value = effects[index] || 'åŠ¹æœãªã—'; });
        updateAndSort();
        window.scrollTo(0, 0);
    }
    
    // === åˆæœŸåŒ–å‡¦ç† ===
    function generateSealableGroups() {
        const groups = [];
        groups.push({ group: "ã“ã†ã’ãåŠ›+?", score: ALL_EFFECTS_DATA["ã“ã†ã’ãåŠ›+25"] });
        groups.push({ group: "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+?", score: ALL_EFFECTS_DATA["ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50"] });
        groups.push({ group: "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+?%", score: ALL_EFFECTS_DATA["ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%"] });
        WEAPON_NAMES.forEach(weapon => {
            const baseScore = WEAPON_EFFECTS[weapon];
            ELEMENTS.forEach(element => { groups.push({ group: `${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, score: baseScore + 3 }); });
        });
        Object.keys(MONSTER_TYPES).forEach(type => {
            const baseScore = MONSTER_TYPES[type];
            groups.push({ group: `${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, score: baseScore + 3 });
        });
        groups.push({ group: "ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»", score: ALL_EFFECTS_DATA["ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»"] });
        groups.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return a.group.localeCompare(b.group, 'ja');
        });
        sealableGroups = groups.map(g => g.group);
    }

    function createEffectSelects() {
        const labels = ["ã‚«ãƒ†ã‚´ãƒªãƒ¼", "åŠ¹æœ 1", "åŠ¹æœ 2", "åŠ¹æœ 3", "åŠ¹æœ 4", "åŠ¹æœ 5"];
        labels.forEach((labelText, index) => {
            const block = document.createElement("div");
            block.className = "effect-block";
            const label = document.createElement("label");
            label.textContent = labelText;
            const searchInput = document.createElement("input");
            searchInput.type = "text";
            searchInput.className = "effect-search";
            searchInput.placeholder = "åŠ¹æœã‚’æ¤œç´¢ã—ã¦çµã‚Šè¾¼ã¿...";
            const select = document.createElement("select");
            select.dataset.type = index === 0 ? "category" : "effect";
            select.addEventListener("change", updateAndSort);
            searchInput.addEventListener("input", updateAndSort);
            block.appendChild(label);
            block.appendChild(searchInput);
            block.appendChild(select);
            container.appendChild(block);
        });
        updateAllSelectOptions();
    }
    
    function createFilterButtons() {
        filterButtonGroup.innerHTML = "";
        const filterConfigs = [
            { filter: "all", text: "ã™ã¹ã¦è¡¨ç¤º" },
            { filter: "general", text: "æ±ç”¨ãƒ™ãƒ«ãƒˆ" },
            ...WEAPON_NAMES.map(name => ({ filter: name, text: `${name}ç”¨` })),
            { filter: "pending", text: "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ" },
            { filter: "storage", text: "å–ã‚Šæ•¢ãˆãšåç´" }
        ];
        filterConfigs.forEach(({ filter, text }) => {
            const button = document.createElement("button");
            button.dataset.filter = filter;
            button.textContent = text;
            button.addEventListener("click", () => { currentFilter = button.dataset.filter; updateDisplay(); });
            filterButtonGroup.appendChild(button);
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion !== DATA_VERSION) {
            migrateSavedBelts();
        }
        generateSealableGroups();
        createEffectSelects();
        createFilterButtons();
        updateAndSort();
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', (e) => { if (e.target === sealModal) sealModal.style.display = 'none'; });
        updateDisplay();
    });
  </script>
</body>
</html>
