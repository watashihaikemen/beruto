<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ« å†ä¿®æ­£(ver1.8.3 UIæ”¹å–„ç‰ˆ)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 700px; margin: auto; background-color: #f0f2f5; }
    h1 { text-align: center; color: #333; }
    .effect-block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; }
    label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
    .effect-search {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px; /* selectã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
    #totalScore { display: none; } /* åˆè¨ˆç‚¹æ•°ã‚’éè¡¨ç¤ºã« */
    .button-group { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px; }
    .button-group button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; }
    #saveButton { background-color: #28a745; }
    #saveButton:hover { background-color: #218838; }
    #sealSettingsButton { background-color: #6c757d; }
    #sealSettingsButton:hover { background-color: #5a6268; }

    #savedBeltsSection { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
    #savedBeltsSection h2 { text-align: center; color: #333; }
    #savedBeltsCount { font-size: 16px; color: #666; font-weight: normal; margin-left: 8px; }
    .saved-belt-item { display: flex; align-items: center; gap: 12px; padding: 15px; margin-bottom: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.2s ease-in-out; }
    .saved-belt-item:hover { background-color: #fcfcfc; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .saved-belt-item.selected { background-color: #e6f7ff; border-left-color: #007bff; }
    .belt-selector { flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; }
    .saved-belt-info { cursor: pointer; flex-grow: 1; }
    .saved-belt-info strong { display: none; }

    /* â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šå…ƒã®spanã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯å‰Šé™¤ã—ã€æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã§ç®¡ç†ã—ã¾ã™â˜…â˜…â˜… */
    .belt-memo { display: block; font-size: 13px !important; color: #007bff !important; font-style: italic; margin-top: 8px !important; }

    /* â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šç‹å† è¡¨ç¤ºã¨æ–‡å­—ã‚ºãƒ¬é˜²æ­¢ã®ãŸã‚ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ â˜…â˜…â˜… */
    .effect-display-line {
        display: flex;
        align-items: baseline;
        margin-top: 4px;
    }
    .effect-display-line > span:last-child {
        font-size: 14px;
        color: #666;
    }
    .crown-container {
        width: 1.5em; /* ç‹å† ä¸€æ–‡å­—åˆ†ã®å¹…ã‚’ç¢ºä¿ */
        flex-shrink: 0;
        text-align: center;
    }
    /* â˜…â˜…â˜…å¤‰æ›´ç‚¹ã“ã“ã¾ã§â˜…â˜…â˜… */

    /* â˜…â˜…â˜…è¿½åŠ ï¼šç†è«–å€¤ãƒ»æº–ç†è«–å€¤ãƒ™ãƒ«ãƒˆã®è±ªè¯ãªã‚¹ã‚¿ã‚¤ãƒ«â˜…â˜…â˜… */
    .belt-theoretical {
        background: linear-gradient(145deg, #fffde7 10%, #fceabb 100%);
        border: 2px solid #fbc02d;
        box-shadow: 0 0 15px rgba(251, 192, 45, 0.6), 0 4px 12px rgba(0,0,0,0.15);
    }
    .belt-theoretical:hover {
        background: linear-gradient(145deg, #fffde7 10%, #fceabb 100%);
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 0 25px rgba(251, 192, 45, 0.8), 0 6px 16px rgba(0,0,0,0.2);
    }

    .belt-near-theoretical {
        background: linear-gradient(145deg, #f5f5f5 10%, #e0e0e0 100%);
        border: 2px solid #bdbdbd;
        box-shadow: 0 0 10px rgba(158, 158, 158, 0.5), 0 4px 12px rgba(0,0,0,0.1);
    }
    .belt-near-theoretical:hover {
        background: linear-gradient(145deg, #f5f5f5 10%, #e0e0e0 100%);
        transform: translateY(-4px) scale(1.01);
        box-shadow: 0 0 18px rgba(158, 158, 158, 0.7), 0 6px 16px rgba(0,0,0,0.15);
    }
    /* â˜…â˜…â˜…è¿½åŠ ã“ã“ã¾ã§â˜…â˜…â˜… */

    .saved-belt-actions { display: flex; flex-direction: column; flex-shrink: 0; margin-left: 10px; gap: 5px; }
    .saved-belt-actions-upper { display: flex; gap: 5px; }
    .saved-belt-actions button { color: white; border: none; padding: 5px 8px; font-size: 12px; border-radius: 3px; cursor: pointer; }
    .saved-belt-memo-edit { background-color: #ffc107; color: #212529; width: 100%; }
    .saved-belt-memo-edit:hover { background-color: #e0a800; }
    .saved-belt-lock { background-color: #17a2b8; }
    .saved-belt-lock:hover { background-color: #138496; }
    .saved-belt-delete { background-color: #dc3545; }
    .saved-belt-delete:hover { background-color: #c82333; }
    .saved-belt-delete:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }

    .action-button-group { text-align: center; margin-bottom: 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
    .action-button-group button { padding: 8px 15px; font-size: 14px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; margin: 0; }
    .action-button-group button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .action-button-group button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.7; }

    fieldset {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px 15px 15px 15px; /* ä¸Šã€å·¦å³ã€ä¸‹ */
      margin-bottom: 15px;
      background-color: #fafafa;
    }
    legend {
      font-weight: bold;
      font-size: 0.9em;
      padding: 0 8px;
      color: #333;
    }
    #bulkActionsContainer {
        border-bottom: none;
        padding-bottom: 0;
    }
    .action-button-group {
        margin-top: 5px; /* legendã¨ã®é–“ã«å°‘ã—ä½™ç™½ */
    }

    #deleteAllUnlockedButton { background-color: #c82333; color: white; border-color: #c82333; }
    #deleteAllUnlockedButton:hover { background-color: #a71d2a; }

    /* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã”ã¨ã®è‰²ã‚’å®šç¾© */
    .category-general { background-color: #e0f7fa; border-left: 5px solid #00acc1; }
    .category-pending { background-color: #fffde7; border-left: 5px solid #ffc107; }
    .category-storage { background-color: #eceff1; border-left: 5px solid #607d8b; }
    .category-default { background-color: #ffffff; border-left: 5px solid #dddddd; }
    .category-weapon-0 { background-color: #FBE9E7; border-left: 5px solid #FF5722; } .category-weapon-1 { background-color: #FCE4EC; border-left: 5px solid #E91E63; } .category-weapon-2 { background-color: #F3E5F5; border-left: 5px solid #9C27B0; } .category-weapon-3 { background-color: #E3F2FD; border-left: 5px solid #2196F3; } .category-weapon-4 { background-color: #E8EAF6; border-left: 5px solid #3F51B5; } .category-weapon-5 { background-color: #E0F2F1; border-left: 5px solid #009688; } .category-weapon-6 { background-color: #E8F5E9; border-left: 5px solid #4CAF50; } .category-weapon-7 { background-color: #F1F8E9; border-left: 5px solid #8BC34A; } .category-weapon-8 { background-color: #FFF3E0; border-left: 5px solid #FF9800; } .category-weapon-9 { background-color: #FFFDE7; border-left: 5px solid #FFEB3B; } .category-weapon-10 { background-color: #FBE9E7; border-left: 5px solid #FF7043; } .category-weapon-11 { background-color: #EDE7F6; border-left: 5px solid #7E57C2; } .category-weapon-12 { background-color: #E1F5FE; border-left: 5px solid #29B6F6; } .category-weapon-13 { background-color: #E0F7FA; border-left: 5px solid #26C6DA; } .category-weapon-14 { background-color: #F0F4C3; border-left: 5px solid #D4E157; }

    /* å°å°è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h2 { margin-top: 0; display: flex; align-items: center; justify-content: space-between; }
    #sealedCount { font-size: 1rem; color: #555; font-weight: normal; margin-left: 10px; }
    #sealActionButtons { justify-content: flex-start; margin-bottom: 15px; }
    .modal-actions { text-align: right; margin-top: 20px; }
    .modal-actions button { margin-left: 10px; padding: 8px 15px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
    #saveSealSettingsButton { background-color: #007bff; color: white; border-color: #007bff;}
    #sealGroupsContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; margin-top: 15px; }
    .seal-group label { display: flex; align-items: center; font-size: 14px; font-weight: normal; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    .seal-group label:hover { background-color: #f0f0f0; }
    .seal-group input { margin-right: 8px; }

    /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .toast { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 25px; font-size: 14px; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <h1>æˆ¦ç¥ã®ãƒ™ãƒ«ãƒˆç®¡ç†ãƒ„ãƒ¼ãƒ«</h1>

  <div id="effectsContainer"></div>
  <div id="totalScore">åˆè¨ˆç‚¹æ•°: 0.0</div>

  <div class="button-group">
    <button id="sealSettingsButton">å°å°åŠ¹æœã®ç®¡ç†</button>
    <button id="saveButton">ç¾åœ¨ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜</button>
  </div>

  <div id="savedBeltsSection">
    <h2>ä¿å­˜ã•ã‚ŒãŸãƒ™ãƒ«ãƒˆ<span id="savedBeltsCount"></span></h2>

    <fieldset>
      <legend>ä¸€æ‹¬æ“ä½œ</legend>
      <div id="bulkActionsContainer" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>çµã‚Šè¾¼ã¿</legend>
      <div id="filterButtonGroup" class="action-button-group"></div>
    </fieldset>

    <fieldset>
      <legend>ä¸¦ã³æ›¿ãˆ</legend>
      <div class="action-button-group" id="sortButtonGroup">
        <button id="sortDivine">ç¥ãƒ™ãƒ«ãƒˆé †</button>
        <button id="sortTrash">ã‚´ãƒŸãƒ™ãƒ«ãƒˆé †</button>
      </div>
    </fieldset>
    <div id="savedBeltsList"></div>
  </div>

  <div id="sealModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2><span>å°å°åŠ¹æœã®ç®¡ç†</span><span id="sealedCount"></span></h2>
        <p>å°å°ã—ãŸã„åŠ¹æœã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚ãƒã‚§ãƒƒã‚¯ã—ãŸåŠ¹æœã¯ã€åŠ¹æœé¸æŠã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¡¨ç¤ºã•ã‚Œãªããªã‚Šã¾ã™ã€‚é¸æŠå¾Œã€ä¿å­˜ã™ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
        <div id="sealActionButtons" class="action-button-group"></div>
        <div id="sealGroupsContainer"></div>
        <div class="modal-actions">
            <button id="cancelSealSettingsButton">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="saveSealSettingsButton">ä¿å­˜ã™ã‚‹</button>
        </div>
    </div>
  </div>

  <div id="toast-container"></div>

  <script>
    // === å®šæ•°å®šç¾© ===
    const DATA_VERSION = '1.8.3';
    const SAVED_BELTS_KEY = 'savedBelts';
    const DATA_VERSION_KEY = 'savedBeltsVersion';
    const SEALED_EFFECTS_KEY = 'sealedEffects';
    const WEAPON_EFFECTS = {
        "å³æ‰‹ã«ç‰‡æ‰‹å‰£": 18, "ä¸¡æ‰‹å‰£": 17.9, "å³æ‰‹ã«çŸ­å‰£": 17.8, "å³æ‰‹ã«ã‚¹ãƒ†ã‚£ãƒƒã‚¯": 17.7, "ä¸¡æ‰‹æ–": 17.6,
        "ãƒ¤ãƒª": 17.5, "ã‚ªãƒ": 17.4, "æ£": 17.3, "ãƒ„ãƒ¡": 17.2, "ãƒ ãƒ": 17.1,
        "å³æ‰‹ã«æ‰‡": 17.0, "å³æ‰‹ã«ãƒãƒ³ãƒãƒ¼": 16.9, "å³æ‰‹ã«ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³": 16.8, "å¼“": 16.7, "éŒ": 16.6
    };
    const WEAPON_NAMES = Object.keys(WEAPON_EFFECTS);
    const WEAPON_NAMES_FOR_CATEGORY = [
        "ç‰‡æ‰‹å‰£", "ä¸¡æ‰‹å‰£", "çŸ­å‰£", "ã‚¹ãƒ†ã‚£ãƒƒã‚¯", "ä¸¡æ‰‹æ–", "ãƒ¤ãƒª", "ã‚ªãƒ", "æ£", "ãƒ„ãƒ¡", "ãƒ ãƒ", "æ‰‡", "ãƒãƒ³ãƒãƒ¼", "ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³", "å¼“", "éŒ"
    ];
    const ELEMENTS = ["ç‚", "æ°·", "é¢¨", "é›·", "åœŸ", "é—‡", "å…‰"];
    const MONSTER_TYPES = { "ãƒ‰ãƒ©ã‚´ãƒ³ç³»": 16.5, "è™«ç³»": 16.4, "ç£ç³»": 16.3, "ã‚¾ãƒ³ãƒ“ç³»": 16.2, "æ¤ç‰©ç³»": 16.1, "æ€ªäººç³»": 16.0, "æ‚ªé­”ç³»": 15.9, "ã‚¨ãƒ¬ç³»": 15.8, "é³¥ç³»": 15.7, "ç‰©è³ªç³»": 15.6, "ã‚¹ãƒ©ã‚¤ãƒ ç³»": 15.5, "ãƒã‚·ãƒ³ç³»": 15.4, "æ°´ç³»": 15.3 };

    // === ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆé–¢æ•° ===
    function createAllEffectsData() {
        const categoryScores = { "æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 40000, "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 6000, "å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)": 4000 };
        let weaponScore = 38000;
        WEAPON_NAMES_FOR_CATEGORY.forEach(name => {
            categoryScores[`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`] = weaponScore;
            weaponScore -= 2000;
        });
        const effectScores = { "åŠ¹æœãªã—": -30, "ã“ã†ã’ãåŠ›+15": 15, "ã“ã†ã’ãåŠ›+20": 21.8, "ã“ã†ã’ãåŠ›+25": 22, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+30": 14.9, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+40": 21.7, "ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50": 21.9, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.0%": 14.8, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+1.5%": 21.7, "ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%": 21.8, "ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»": 0.05 };
        Object.keys(WEAPON_EFFECTS).forEach(weapon => {
            const baseScore = WEAPON_EFFECTS[weapon];
            ELEMENTS.forEach(element => {
                [12, 13, 14, 15].forEach(val => {
                    effectScores[`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+${val}%`] = baseScore + (val - 12);
                });
            });
        });
        Object.keys(MONSTER_TYPES).forEach(type => {
            const baseScore = MONSTER_TYPES[type];
            for(let i = 0; i < 4; i++) {
                effectScores[`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+${9+i}%`] = baseScore + i;
            }
        });
        return { ...categoryScores, ...effectScores };
    }
    const ALL_EFFECTS_DATA = createAllEffectsData();

    function createFilters() {
        const filters = { all: { min: -Infinity, max: Infinity }, general: { min: 39849, max: 40499 }, pending: { min: 5849, max: 7848 }, storage: { min: 3849, max: 5848 } };
        let weaponScore = 38000;
        WEAPON_NAMES_FOR_CATEGORY.forEach(name => {
            const minScore = weaponScore - 2000;
            filters[name] = { min: minScore + 1849, max: weaponScore + 1848 };
            weaponScore -= 2000;
        });
        return filters;
    }
    const FILTERS = createFilters();

    // === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ===
    let sealableGroups = [];
    let groupKeyDataMap = new Map();
    let maxEffectInGroupMap = new Map(); // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šæœ€å¤§å€¤åŠ¹æœã‚’ä¿æŒã™ã‚‹Mapã‚’è¿½åŠ â˜…â˜…â˜…
    let fullOptionsFragment, categoryOptionsFragment, effectOptionsFragment;
    let currentFilter = 'all';
    let currentSortDirection = 'divine';
    let isSorting = false;

    // === DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ (DOMContentLoadedå†…ã§è¨­å®š) ===
    let container, savedBeltsList, saveButton, sortDivineButton, sortTrashButton, savedBeltsCountElement, filterButtonGroup, sortButtonGroup, sealSettingsButton, sealModal, sealActionButtonsContainer, sealGroupsContainer, saveSealSettingsButton, cancelSealSettingsButton, sealedCountElement, toastContainer, bulkActionsContainer;
    let selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton;

    // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ===
    function showToast(message) { const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = message; toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
    function getSavedBelts() { try { const beltsJSON = localStorage.getItem(SAVED_BELTS_KEY); return beltsJSON ? JSON.parse(beltsJSON) : []; } catch (e) { console.error("Failed to parse saved belts:", e); return []; } }
    function saveBelts(belts) { localStorage.setItem(SAVED_BELTS_KEY, JSON.stringify(belts)); }
    function calculateTotalScore(effects) { return effects.reduce((score, effect) => score + (ALL_EFFECTS_DATA[effect] || 0), 0); }

    const getGroupKeyForEffect = (() => {
        const cache = new Map();
        const regex = /(\s*\+[\d\.]+%?)$/;
        return (effect) => {
            if (cache.has(effect)) return cache.get(effect);
            if (!effect || effect === 'åŠ¹æœãªã—' || effect.includes('(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)')) {
                cache.set(effect, null);
                return null;
            }
            const key = effect.replace(regex, '').trim();
            const result = (key && key !== effect) ? key : effect;
            cache.set(effect, result);
            return result;
        };
    })();

    // === å°å°æ©Ÿèƒ½é–¢é€£ ===
    function getSealedGroups() { try { const sealedJSON = localStorage.getItem(SEALED_EFFECTS_KEY); return sealedJSON ? JSON.parse(sealedJSON) : []; } catch (e) { console.error("Failed to parse sealed effects:", e); return []; } }
    function isEffectSealed(effect, sealedGroups) { if (!sealedGroups || sealedGroups.length === 0) return false; const groupKey = getGroupKeyForEffect(effect); return groupKey ? sealedGroups.some(g => g.startsWith(groupKey)) : false; }
    function updateSealedCount() { if (!sealableGroups || sealableGroups.length === 0) return; const checkedCount = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked').length; const totalCount = sealableGroups.length; sealedCountElement.textContent = `(${checkedCount} / ${totalCount} ä»¶ å°å°ä¸­)`; }
    function populateSealModal() { sealActionButtonsContainer.innerHTML = ''; const selectAllButton = document.createElement('button'); selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ'; selectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateSealedCount(); }); const deselectAllButton = document.createElement('button'); deselectAllButton.textContent = 'ã™ã¹ã¦è§£é™¤'; deselectAllButton.addEventListener('click', () => { sealGroupsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateSealedCount(); }); sealActionButtonsContainer.appendChild(selectAllButton); sealActionButtonsContainer.appendChild(deselectAllButton); sealGroupsContainer.innerHTML = ''; const sealedGroups = getSealedGroups(); sealableGroups.forEach(group => { const div = document.createElement('div'); div.className = 'seal-group'; const label = document.createElement('label'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = group; checkbox.checked = sealedGroups.includes(group); checkbox.addEventListener('change', updateSealedCount); label.appendChild(checkbox); label.appendChild(document.createTextNode(group)); div.appendChild(label); sealGroupsContainer.appendChild(div); }); updateSealedCount(); }
    function saveSealSettings() { const checkboxes = sealGroupsContainer.querySelectorAll('input[type="checkbox"]:checked'); const sealedGroups = Array.from(checkboxes).map(cb => cb.value); localStorage.setItem(SEALED_EFFECTS_KEY, JSON.stringify(sealedGroups)); sealModal.style.display = 'none'; updateAllSelectOptions(); showToast("å°å°è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚"); }

    // === ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç† (ä¿å­˜/å‰Šé™¤/æ›´æ–°) ===
    function migrateSavedBelts() {
        const storedVersion = localStorage.getItem(DATA_VERSION_KEY);
        if (storedVersion === DATA_VERSION) return;
        let savedBelts = getSavedBelts();
        const migratedBelts = savedBelts.map(belt => {
            let currentBelt = belt;
            if (Array.isArray(currentBelt)) currentBelt = { effects: currentBelt, locked: false, memo: '' };
            if (typeof currentBelt !== 'object' || currentBelt === null || !Array.isArray(currentBelt.effects)) return null;
            const newEffects = currentBelt.effects.map(effect => {
                let newEffect = effect;
                newEffect = newEffect.replace(/^å³æ‰‹ã«(ç‰‡æ‰‹å‰£|çŸ­å‰£|ã‚¹ãƒ†ã‚£ãƒƒã‚¯|æ‰‡|ãƒãƒ³ãƒãƒ¼|ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³)ç”¨ãƒ™ãƒ«ãƒˆ/, '$1ç”¨ãƒ™ãƒ«ãƒˆ');
                newEffect = newEffect.replace(/^(ç‰‡æ‰‹å‰£|çŸ­å‰£|ã‚¹ãƒ†ã‚£ãƒƒã‚¯|æ‰‡|ãƒãƒ³ãƒãƒ¼|ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³)è£…å‚™æ™‚/, 'å³æ‰‹ã«$1è£…å‚™æ™‚');
                return newEffect;
            });
            return { effects: newEffects, locked: !!currentBelt.locked, memo: currentBelt.memo || '' };
        }).filter(Boolean);
        saveBelts(migratedBelts);
        localStorage.setItem(DATA_VERSION_KEY, DATA_VERSION);
        console.log(`ãƒ™ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ver ${DATA_VERSION} ã«æ›´æ–°ã—ã¾ã—ãŸã€‚`);
        showToast("ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æœ€æ–°ç‰ˆã«æ›´æ–°ã—ã¾ã—ãŸã€‚");
    }

    function saveCurrentBelt() {
        const currentEffects = Array.from(container.querySelectorAll('select')).map(s => s.value);
        if (currentEffects.slice(1).every(e => e === 'åŠ¹æœãªã—')) {
            showToast("æœ‰åŠ¹ãªåŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚");
            return;
        }
        const savedBelts = getSavedBelts();
        const newBeltData = { effects: currentEffects, locked: false, memo: '' };
        if (savedBelts.some(belt => JSON.stringify(belt.effects) === JSON.stringify(newBeltData.effects))) {
            showToast("ã“ã®åŠ¹æœã®çµ„ã¿åˆã‚ã›ã¯æ—¢ã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            return;
        }
        const newBeltEffectGroups = new Set(currentEffects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
        if (newBeltEffectGroups.size > 0) {
            let mostSimilar = { count: 0, groups: [] };
            for (const savedBelt of savedBelts) {
                const existingBeltEffectGroups = new Set(savedBelt.effects.slice(1).map(getGroupKeyForEffect).filter(Boolean));
                const intersection = new Set([...newBeltEffectGroups].filter(group => existingBeltEffectGroups.has(group)));
                if (intersection.size > mostSimilar.count) {
                    mostSimilar = { count: intersection.size, groups: [...intersection] };
                }
            }
            if (mostSimilar.count >= 2) {
                const message = `åŠ¹æœãŒ${mostSimilar.count}ã¤é‡è¤‡ã™ã‚‹ãƒ™ãƒ«ãƒˆã‚’æ‰€æœ‰ã—ã¦ã„ã¾ã™ã€‚\n\nåŠ¹æœå†…å®¹:\n${mostSimilar.groups.map(key => groupKeyDataMap.get(key)?.group || key).join('\n')}\n\nãã‚Œã§ã‚‚ã“ã®ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ`;
                if (!confirm(message)) {
                    showToast("ä¿å­˜ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚");
                    return;
                }
            }
        }
        savedBelts.push(newBeltData);
        saveBelts(savedBelts);
        showToast("ãƒ™ãƒ«ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸï¼");
        updateDisplay();
    }

    function deleteBelt(effectsToDelete) { if (!confirm("ã“ã®ãƒ™ãƒ«ãƒˆã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; let savedBelts = getSavedBelts(); const effectsToDeleteStr = JSON.stringify(effectsToDelete); const updatedBelts = savedBelts.filter(belt => JSON.stringify(belt.effects) !== effectsToDeleteStr); saveBelts(updatedBelts); showToast("ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); }
    function editMemo(effectsToEdit) { let savedBelts = getSavedBelts(); const effectsToEditStr = JSON.stringify(effectsToEdit); const beltToEdit = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToEditStr); if (beltToEdit) { const newMemo = prompt("ãƒ™ãƒ«ãƒˆã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", beltToEdit.memo || ""); if (newMemo !== null) { beltToEdit.memo = newMemo.trim(); saveBelts(savedBelts); showToast("ãƒ¡ãƒ¢ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚"); updateDisplay(); } } }
    function toggleLockState(effectsToToggle) { let savedBelts = getSavedBelts(); const effectsToToggleStr = JSON.stringify(effectsToToggle); const beltToToggle = savedBelts.find(belt => JSON.stringify(belt.effects) === effectsToToggleStr); if (beltToToggle) { beltToToggle.locked = !beltToToggle.locked; saveBelts(savedBelts); showToast(beltToToggle.locked ? "ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚" : "ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚"); updateDisplay(); } }

    // === è¡¨ç¤ºé–¢é€£ ===
    // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šç†è«–å€¤ãƒ»æº–ç†è«–å€¤ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ã™ã‚‹ã‚ˆã†ã«ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿®æ­£â˜…â˜…â˜…
    function renderSavedBelts(beltsToRender) {
        savedBeltsList.innerHTML = '';
        const totalSavedCount = getSavedBelts().length;
        savedBeltsCountElement.textContent = `(è¡¨ç¤º: ${beltsToRender.length}å€‹ / åˆè¨ˆ: ${totalSavedCount}å€‹)`;
        if (beltsToRender.length === 0) {
            const noBeltMessage = document.createElement('p');
            noBeltMessage.textContent = 'è¡¨ç¤ºå¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
            noBeltMessage.style.textAlign = 'center';
            noBeltMessage.style.color = '#888';
            savedBeltsList.appendChild(noBeltMessage);
            updateBulkActionButtonsState();
            return;
        }
        const fragment = document.createDocumentFragment();
        const categoryClassMap = new Map([["æ±ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)", "category-general"], ["ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)", "category-pending"], ["å–ã‚Šæ•¢ãˆãšåç´ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)", "category-storage"]]);
        WEAPON_NAMES_FOR_CATEGORY.forEach((name, index) => { categoryClassMap.set(`${name}ç”¨ãƒ™ãƒ«ãƒˆ (ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)`, `category-weapon-${index}`); });
        
        beltsToRender.forEach(({ effects, locked, memo }) => {
            const beltItem = document.createElement('div');
            beltItem.className = 'saved-belt-item';
            beltItem.classList.add(categoryClassMap.get(effects[0]) || 'category-default');
            beltItem.dataset.effectsJson = JSON.stringify(effects);

            // â˜…â˜…â˜…è¿½åŠ ï¼šç†è«–å€¤ãƒ»æº–ç†è«–å€¤ã®åˆ¤å®šã¨ã‚¯ãƒ©ã‚¹ä»˜ä¸â˜…â˜…â˜…
            let crownCount = 0;
            const validEffects = effects.slice(1).filter(e => e !== 'åŠ¹æœãªã—');
            const validEffectCount = validEffects.length;

            validEffects.forEach(effect => {
                const groupKey = getGroupKeyForEffect(effect);
                if (groupKey && maxEffectInGroupMap.get(groupKey) === effect) {
                    crownCount++;
                }
            });

            if (validEffectCount > 0 && crownCount === validEffectCount) {
                beltItem.classList.add('belt-theoretical');
            } else if (crownCount === 4) {
                beltItem.classList.add('belt-near-theoretical');
            }
            // â˜…â˜…â˜…è¿½åŠ ã“ã“ã¾ã§â˜…â˜…â˜…

            const effectsHtml = effects.filter(e => e !== 'åŠ¹æœãªã—').map(effect => {
                const groupKey = getGroupKeyForEffect(effect);
                const isMax = groupKey && maxEffectInGroupMap.get(groupKey) === effect;
                const crownHtml = isMax ? 'ğŸ‘‘' : '';
                return `
                    <div class="effect-display-line">
                        <span class="crown-container">${crownHtml}</span>
                        <span>${effect}</span>
                    </div>`;
            }).join('');

            beltItem.innerHTML = `
                <input type="checkbox" class="belt-selector">
                <div class="saved-belt-info">
                    ${effectsHtml}
                    ${memo ? `<span class="belt-memo">ğŸ“ ${memo}</span>` : ''}
                </div>
                <div class="saved-belt-actions">
                    <div class="saved-belt-actions-upper">
                        <button class="saved-belt-lock">${locked ? 'è§£é™¤' : 'ãƒ­ãƒƒã‚¯'}</button>
                        <button class="saved-belt-delete" ${locked ? 'disabled' : ''}>å‰Šé™¤</button>
                    </div>
                    <button class="saved-belt-memo-edit">ãƒ¡ãƒ¢ç·¨é›†</button>
                </div>
            `;
            fragment.appendChild(beltItem);
        });
        savedBeltsList.appendChild(fragment);
        updateBulkActionButtonsState();
    }


    // === ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã®ç”Ÿæˆãƒ»æ›´æ–° ===
    function rebuildOptionFragments() { fullOptionsFragment = document.createDocumentFragment(); categoryOptionsFragment = document.createDocumentFragment(); effectOptionsFragment = document.createDocumentFragment(); const sealedGroups = getSealedGroups(); for (const effectName in ALL_EFFECTS_DATA) { if (isEffectSealed(effectName, sealedGroups)) continue; const option = document.createElement("option"); option.value = effectName; option.textContent = effectName; fullOptionsFragment.appendChild(option.cloneNode(true)); if (effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") { categoryOptionsFragment.appendChild(option.cloneNode(true)); } if (!effectName.includes("(ã‚«ãƒ†ã‚´ãƒªãƒ¼ç”¨)") || effectName === "åŠ¹æœãªã—") { effectOptionsFragment.appendChild(option.cloneNode(true)); } } }
    function updateAllSelectOptions() { rebuildOptionFragments(); const selects = document.querySelectorAll("#effectsContainer select"); selects.forEach(select => { const currentValue = select.value; const sourceFragment = select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment; select.innerHTML = ""; select.appendChild(sourceFragment.cloneNode(true)); if (Array.from(select.options).some(o => o.value === currentValue)) { select.value = currentValue; } else { select.value = "åŠ¹æœãªã—"; } }); updateAndSort(); }

    // === ä¸¦ã³æ›¿ãˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®ãƒ¡ã‚¤ãƒ³é–¢æ•° ===
    function updateAndSort() {
        if (isSorting) return;
        isSorting = true;
        const allSelects = Array.from(container.querySelectorAll('select'));
        const searchInputs = Array.from(container.querySelectorAll('.effect-search'));
        const originalValues = allSelects.map(s => s.value);
        const sortedEffects = [...originalValues.slice(1)].sort((a, b) => (ALL_EFFECTS_DATA[b] || 0) - (ALL_EFFECTS_DATA[a] || 0));
        const finalValues = [originalValues[0], ...sortedEffects];
        
        allSelects.forEach((select, currentIndex) => {
            const finalValueForThisSelect = finalValues[currentIndex];
            const searchTerm = searchInputs[currentIndex] ? searchInputs[currentIndex].value.toLowerCase() : '';
            const otherUsedGroupKeys = new Set(finalValues.map((v, i) => (currentIndex !== i ? getGroupKeyForEffect(v) : null)).filter(Boolean));
            
            const sourceFragment = select.dataset.type === 'category' ? categoryOptionsFragment : effectOptionsFragment;
            const newOptionsFragment = document.createDocumentFragment();
            
            Array.from(sourceFragment.children).forEach(optionNode => {
                const optionValue = optionNode.value;
                const optionGroupKey = getGroupKeyForEffect(optionValue);
                const isSelectableByGroup = !optionGroupKey || !otherUsedGroupKeys.has(optionGroupKey) || optionValue === finalValueForThisSelect;
                const matchesSearch = !searchTerm || optionNode.textContent.toLowerCase().includes(searchTerm);
                if (isSelectableByGroup && matchesSearch) {
                    newOptionsFragment.appendChild(optionNode.cloneNode(true));
                }
            });
            
            select.innerHTML = '';
            select.appendChild(newOptionsFragment);
            
            if (!Array.from(select.options).some(opt => opt.value === finalValueForThisSelect) && finalValueForThisSelect !== 'åŠ¹æœãªã—') {
                const restoredOption = document.createElement('option');
                restoredOption.value = finalValueForThisSelect;
                restoredOption.textContent = finalValueForThisSelect;
                select.insertBefore(restoredOption, select.firstChild);
            }
            select.value = finalValueForThisSelect;
        });
        
        document.getElementById("totalScore").textContent = `åˆè¨ˆç‚¹æ•°: ${calculateTotalScore(finalValues).toFixed(1)}`;
        isSorting = false;
    }

    // === è¡¨ç¤ºæ›´æ–°ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆ ===
    function updateDisplay() { let allBelts = getSavedBelts(); let beltsWithScore = allBelts.map(beltData => ({ ...beltData, score: calculateTotalScore(beltData.effects) })); const filterRange = FILTERS[currentFilter]; let filteredBelts = beltsWithScore.filter(belt => belt.score >= filterRange.min && belt.score <= filterRange.max); filteredBelts.sort((a, b) => currentSortDirection === 'divine' ? b.score - a.score : a.score - b.score); renderSavedBelts(filteredBelts); updateActiveButtons(); }
    function updateActiveButtons() { filterButtonGroup.querySelectorAll("button").forEach(btn => btn.classList.toggle("active", btn.dataset.filter === currentFilter)); sortButtonGroup.querySelectorAll("button").forEach(btn => btn.classList.toggle("active", (btn.id === "sortDivine" && currentSortDirection === "divine") || (btn.id === "sortTrash" && currentSortDirection === "trash"))); }
    function loadBelt(effects) { const selects = container.querySelectorAll('select'); const searchInputs = container.querySelectorAll('.effect-search'); searchInputs.forEach(input => { input.value = ""; }); selects.forEach((select, index) => { select.value = effects[index] || 'åŠ¹æœãªã—'; }); updateAndSort(); window.scrollTo(0, 0); }

    // === ä¸€æ‹¬æ“ä½œé–¢é€£ã®é–¢æ•° ===
    function setupBulkActionButtons() {
        bulkActionsContainer.innerHTML = '';
        selectAllButton = document.createElement('button');
        selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ';
        lockSelectedButton = document.createElement('button');
        lockSelectedButton.textContent = 'é¸æŠã‚’ãƒ­ãƒƒã‚¯';
        unlockSelectedButton = document.createElement('button');
        unlockSelectedButton.textContent = 'é¸æŠã‚’ãƒ­ãƒƒã‚¯è§£é™¤';
        deleteSelectedButton = document.createElement('button');
        deleteSelectedButton.textContent = 'é¸æŠã‚’å‰Šé™¤ï¼ˆãƒ­ãƒƒã‚¯ã‚’é™¤ãï¼‰';
        lockAllButton = document.createElement('button');
        lockAllButton.textContent = 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯';
        unlockAllButton = document.createElement('button');
        unlockAllButton.textContent = 'ã™ã¹ã¦ãƒ­ãƒƒã‚¯è§£é™¤';
        deleteAllUnlockedButton = document.createElement('button');
        deleteAllUnlockedButton.id = 'deleteAllUnlockedButton';
        deleteAllUnlockedButton.textContent = 'å…¨å‰Šé™¤(ãƒ­ãƒƒã‚¯é™¤ã)';
        bulkActionsContainer.append(selectAllButton, lockSelectedButton, unlockSelectedButton, deleteSelectedButton, lockAllButton, unlockAllButton, deleteAllUnlockedButton);
    }
    function updateBulkActionButtonsState() { const selectedCount = savedBeltsList.querySelectorAll('.belt-selector:checked').length; const totalCount = savedBeltsList.querySelectorAll('.belt-selector').length; lockSelectedButton.disabled = selectedCount === 0; unlockSelectedButton.disabled = selectedCount === 0; deleteSelectedButton.disabled = selectedCount === 0; if (totalCount === 0) { selectAllButton.textContent = 'ã™ã¹ã¦é¸æŠ'; selectAllButton.disabled = true; } else { selectAllButton.disabled = false; selectAllButton.textContent = selectedCount === 0 ? 'ã™ã¹ã¦é¸æŠ' : selectedCount === totalCount ? 'ã™ã¹ã¦è§£é™¤' : `é¸æŠä¸­ ${selectedCount}`; } }
    function toggleSelectAll() { const checkboxes = savedBeltsList.querySelectorAll('.belt-selector'); const shouldSelectAll = Array.from(checkboxes).some(cb => !cb.checked); checkboxes.forEach(cb => { if (cb.checked !== shouldSelectAll) { cb.checked = shouldSelectAll; cb.closest('.saved-belt-item').classList.toggle('selected', shouldSelectAll); } }); updateBulkActionButtonsState(); }
    function getSelectedEffectsJson() { return Array.from(savedBeltsList.querySelectorAll('.belt-selector:checked')).map(cb => cb.closest('.saved-belt-item').dataset.effectsJson); }
    function operateOnSelectedBelts(operation) {
        const selectedEffectsJson = getSelectedEffectsJson();
        if (selectedEffectsJson.length === 0) { showToast("ãƒ™ãƒ«ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }
        operation(selectedEffectsJson);
    }
    function lockSelectedBelts() { operateOnSelectedBelts(selected => { if (confirm(`é¸æŠã—ãŸ ${selected.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ`)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (selected.includes(JSON.stringify(b.effects)) && !b.locked) { b.locked = true; count++; } }); if (count > 0) { saveBelts(belts); showToast(`${count} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`); updateDisplay(); } else { showToast(`ãƒ­ãƒƒã‚¯å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`); } } }); }
    function unlockSelectedBelts() { operateOnSelectedBelts(selected => { if (confirm(`é¸æŠã—ãŸ ${selected.length} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ`)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (selected.includes(JSON.stringify(b.effects)) && b.locked) { b.locked = false; count++; } }); if (count > 0) { saveBelts(belts); showToast(`${count} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`); updateDisplay(); } else { showToast(`ãƒ­ãƒƒã‚¯è§£é™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`); } } }); }
    function deleteSelectedBelts() { operateOnSelectedBelts(selected => { const allBelts = getSavedBelts(); const toDelete = allBelts.filter(b => selected.includes(JSON.stringify(b.effects)) && !b.locked); const lockedCount = selected.length - toDelete.length; if (toDelete.length === 0) { showToast('å‰Šé™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚(ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒ™ãƒ«ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“)'); return; } let confirmMsg = `é¸æŠã—ãŸ ${toDelete.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`; if (lockedCount > 0) confirmMsg += `\n\n(æ³¨æ„: ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ ${lockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“)`; if (confirm(confirmMsg)) { const toDeleteSet = new Set(toDelete.map(b => JSON.stringify(b.effects))); const updatedBelts = allBelts.filter(b => !toDeleteSet.has(JSON.stringify(b.effects))); saveBelts(updatedBelts); showToast(`${toDelete.length} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`); updateDisplay(); } }); }
    function operateOnAllBelts(operation) { if (confirm(operation.confirmMessage)) { let belts = getSavedBelts(); let count = 0; belts.forEach(b => { if (operation.predicate(b)) { operation.action(b); count++; } }); if (count > 0) { saveBelts(belts); showToast(operation.successMessage(count)); updateDisplay(); } else { showToast(operation.noChangeMessage); } } }
    function lockAllBelts() { operateOnAllBelts({ confirmMessage: 'ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ', predicate: b => !b.locked, action: b => b.locked = true, successMessage: count => `${count} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`, noChangeMessage: 'ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã¯æ—¢ã«ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚' }); }
    function unlockAllBelts() { operateOnAllBelts({ confirmMessage: 'ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ', predicate: b => b.locked, action: b => b.locked = false, successMessage: count => `${count} å€‹ã®ãƒ™ãƒ«ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`, noChangeMessage: 'ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒ™ãƒ«ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚' }); }
    function deleteAllUnlockedBelts() { const savedBelts = getSavedBelts(); const unlockedCount = savedBelts.filter(b => !b.locked).length; if (unlockedCount === 0) { showToast('å‰Šé™¤å¯¾è±¡ã®ãƒ™ãƒ«ãƒˆ(ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ãƒ™ãƒ«ãƒˆ)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; } if (confirm(`ã€å±é™ºã€‘ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ ${unlockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å…ƒã«æˆ»ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ï¼`)) { const confirmationText = 'delete'; const userInput = prompt(`æœ¬å½“ã«å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ã€Œ${confirmationText}ã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`); if (userInput === confirmationText) { const updatedBelts = savedBelts.filter(b => b.locked); saveBelts(updatedBelts); showToast(`ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ ${unlockedCount} å€‹ã®ãƒ™ãƒ«ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã—ãŸã€‚`); updateDisplay(); } else { showToast('å…¥åŠ›ãŒä¸€è‡´ã—ãªã‹ã£ãŸãŸã‚ã€å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚'); } } }

    // === åˆæœŸåŒ–å‡¦ç† ===
    function generateSealableGroups() {
        groupKeyDataMap.clear();
        const addGroup = (name, score) => { const key = name.replace(/\+\?%?/, '').trim(); if (!groupKeyDataMap.has(key)) groupKeyDataMap.set(key, { group: name, score: score }); };
        addGroup("ã“ã†ã’ãåŠ›+?", ALL_EFFECTS_DATA["ã“ã†ã’ãåŠ›+25"]);
        addGroup("ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+?", ALL_EFFECTS_DATA["ã“ã†ã’ãé­”åŠ›ã¨å›å¾©é­”åŠ›+50"]);
        addGroup("ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+?%", ALL_EFFECTS_DATA["ä¼šå¿ƒç‡ã¨å‘ªæ–‡æš´èµ°ç‡+2.0%"]);
        WEAPON_NAMES.forEach(weapon => { ELEMENTS.forEach(element => { addGroup(`${weapon}è£…å‚™æ™‚ ${element}ã®æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, WEAPON_EFFECTS[weapon] + 3); }); });
        Object.keys(MONSTER_TYPES).forEach(type => addGroup(`${type}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸+?%`, MONSTER_TYPES[type] + 3));
        addGroup("ç›¾è£…å‚™ã§é–‹æˆ¦æ™‚â—‹â—‹ç³»", 0.05);
        sealableGroups = Array.from(groupKeyDataMap.values()).sort((a, b) => b.score - a.score || a.group.localeCompare(b.group, 'ja')).map(g => g.group);
    }
    // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šæœ€å¤§å€¤åŠ¹æœãƒãƒƒãƒ—ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’è¿½åŠ â˜…â˜…â˜…
    function generateMaxEffectMap() {
        maxEffectInGroupMap.clear();
        for (const effectName in ALL_EFFECTS_DATA) {
            const groupKey = getGroupKeyForEffect(effectName);
            if (!groupKey) continue;
            const currentScore = ALL_EFFECTS_DATA[effectName];
            const existingMaxEffectName = maxEffectInGroupMap.get(groupKey);
            if (!existingMaxEffectName || currentScore > ALL_EFFECTS_DATA[existingMaxEffectName]) {
                maxEffectInGroupMap.set(groupKey, effectName);
            }
        }
    }
    function createEffectSelects() { const labels = ["ã‚«ãƒ†ã‚´ãƒªãƒ¼", "åŠ¹æœ 1", "åŠ¹æœ 2", "åŠ¹æœ 3", "åŠ¹æœ 4", "åŠ¹æœ 5"]; labels.forEach((labelText, index) => { const block = document.createElement("div"); block.className = "effect-block"; block.innerHTML = `<label>${labelText}</label><input type="text" class="effect-search" placeholder="åŠ¹æœã‚’æ¤œç´¢ã—ã¦çµã‚Šè¾¼ã¿..."><select data-type="${index === 0 ? "category" : "effect"}"></select>`; container.appendChild(block); }); rebuildOptionFragments(); document.querySelectorAll("#effectsContainer select").forEach(select => { select.appendChild((select.dataset.type === "category" ? categoryOptionsFragment : effectOptionsFragment).cloneNode(true)); }); container.addEventListener('change', e => { if (e.target.tagName === 'SELECT') updateAndSort(); }); container.addEventListener('input', e => { if (e.target.classList.contains('effect-search')) updateAndSort(); }); }
    function createFilterButtons() { filterButtonGroup.innerHTML = ""; [{ filter: "all", text: "ã™ã¹ã¦è¡¨ç¤º" }, { filter: "general", text: "æ±ç”¨ãƒ™ãƒ«ãƒˆ" }, ...WEAPON_NAMES_FOR_CATEGORY.map(name => ({ filter: name, text: `${name}ç”¨` })), { filter: "pending", text: "ä¿ç•™ä¸­ã®ãƒ™ãƒ«ãƒˆ" }, { filter: "storage", text: "å–ã‚Šæ•¢ãˆãšåç´" }].forEach(({ filter, text }) => { const button = document.createElement("button"); button.dataset.filter = filter; button.textContent = text; filterButtonGroup.appendChild(button); }); }
    
    function initializeEventListeners() {
        // --- ãƒ¡ã‚¤ãƒ³æ“ä½œãƒœã‚¿ãƒ³ ---
        saveButton.addEventListener('click', saveCurrentBelt);
        sortDivineButton.addEventListener('click', () => { currentSortDirection = 'divine'; updateDisplay(); });
        sortTrashButton.addEventListener('click', () => { currentSortDirection = 'trash'; updateDisplay(); });

        // --- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒœã‚¿ãƒ³ (ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³) ---
        filterButtonGroup.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { currentFilter = e.target.dataset.filter; updateDisplay(); } });

        // --- å°å°ãƒ¢ãƒ¼ãƒ€ãƒ« ---
        sealSettingsButton.addEventListener('click', () => { populateSealModal(); sealModal.style.display = 'flex'; });
        cancelSealSettingsButton.addEventListener('click', () => sealModal.style.display = 'none');
        saveSealSettingsButton.addEventListener('click', saveSealSettings);
        sealModal.addEventListener('click', e => { if (e.target === sealModal) sealModal.style.display = 'none'; });

        // --- ä¿å­˜æ¸ˆã¿ãƒ™ãƒ«ãƒˆãƒªã‚¹ãƒˆ (ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³) ---
        savedBeltsList.addEventListener('click', e => {
            const beltItem = e.target.closest('.saved-belt-item');
            if (!beltItem) return;
            const effects = JSON.parse(beltItem.dataset.effectsJson);
            if (e.target.matches('.saved-belt-lock')) toggleLockState(effects);
            else if (e.target.matches('.saved-belt-delete:not(:disabled)')) deleteBelt(effects);
            else if (e.target.matches('.saved-belt-memo-edit')) editMemo(effects);
            else if (e.target.closest('.saved-belt-info')) loadBelt(effects);
        });
        savedBeltsList.addEventListener('change', e => {
            if (e.target.matches('.belt-selector')) {
                e.target.closest('.saved-belt-item').classList.toggle('selected', e.target.checked);
                updateBulkActionButtonsState();
            }
        });

        // --- ä¸€æ‹¬æ“ä½œãƒœã‚¿ãƒ³ ---
        selectAllButton.addEventListener('click', toggleSelectAll);
        lockSelectedButton.addEventListener('click', lockSelectedBelts);
        unlockSelectedButton.addEventListener('click', unlockSelectedBelts);
        deleteSelectedButton.addEventListener('click', deleteSelectedBelts);
        lockAllButton.addEventListener('click', lockAllBelts);
        unlockAllButton.addEventListener('click', unlockAllBelts);
        deleteAllUnlockedButton.addEventListener('click', deleteAllUnlockedBelts);
    }

    document.addEventListener('DOMContentLoaded', () => {
        // --- DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ ---
        container = document.getElementById('effectsContainer');
        savedBeltsList = document.getElementById('savedBeltsList');
        saveButton = document.getElementById('saveButton');
        sortDivineButton = document.getElementById('sortDivine');
        sortTrashButton = document.getElementById('sortTrash');
        savedBeltsCountElement = document.getElementById('savedBeltsCount');
        filterButtonGroup = document.getElementById('filterButtonGroup');
        sortButtonGroup = document.getElementById('sortButtonGroup');
        sealSettingsButton = document.getElementById('sealSettingsButton');
        sealModal = document.getElementById('sealModal');
        sealActionButtonsContainer = document.getElementById('sealActionButtons');
        sealGroupsContainer = document.getElementById('sealGroupsContainer');
        saveSealSettingsButton = document.getElementById('saveSealSettingsButton');
        cancelSealSettingsButton = document.getElementById('cancelSealSettingsButton');
        sealedCountElement = document.getElementById('sealedCount');
        toastContainer = document.getElementById('toast-container');
        bulkActionsContainer = document.getElementById('bulkActionsContainer');
        
        // --- åˆæœŸåŒ–å‡¦ç† ---
        migrateSavedBelts();
        generateSealableGroups();
        generateMaxEffectMap(); // â˜…â˜…â˜…å¤‰æ›´ç‚¹ï¼šæœ€å¤§å€¤ãƒãƒƒãƒ—ç”Ÿæˆé–¢æ•°ã‚’å‘¼ã³å‡ºã—â˜…â˜…â˜…
        createEffectSelects();
        createFilterButtons();
        setupBulkActionButtons();
        initializeEventListeners();
        
        // --- åˆæœŸè¡¨ç¤º ---
        updateAndSort();
        updateDisplay();
    });
  </script>
</body>
</html>
